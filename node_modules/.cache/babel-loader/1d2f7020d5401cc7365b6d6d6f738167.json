{"ast":null,"code":"\"use strict\"; // In Browsers we create an adapter, get the SMART api from it and build the\n// global FHIR object\n\nconst BrowserAdapter_1 = require(\"../adapters/BrowserAdapter\");\n\nconst adapter = new BrowserAdapter_1.default();\nconst {\n  ready,\n  authorize,\n  init,\n  client,\n  options\n} = adapter.getSmartApi(); // We have two kinds of browser builds - \"pure\" for new browsers and \"legacy\"\n// for old ones. In pure builds we assume that the browser supports everything\n// we need. In legacy mode, the library also acts as a polyfill. Babel will\n// automatically polyfill everything except \"fetch\", which we have to handle\n// manually.\n// @ts-ignore\n\nif (typeof FHIRCLIENT_PURE == \"undefined\") {\n  const fetch = require(\"cross-fetch\");\n\n  require(\"abortcontroller-polyfill/dist/abortcontroller-polyfill-only\");\n\n  if (!window.fetch) {\n    window.fetch = fetch.default;\n    window.Headers = fetch.Headers;\n    window.Request = fetch.Request;\n    window.Response = fetch.Response;\n  }\n} // $lab:coverage:off$\n\n\nconst FHIR = {\n  AbortController: window.AbortController,\n  client,\n  oauth2: {\n    settings: options,\n    ready,\n    authorize,\n    init\n  }\n};\nmodule.exports = FHIR; // $lab:coverage:on$","map":{"version":3,"sources":["/Users/rajvansia/Documents/GitHub/lab4-react-working/node_modules/fhirclient/lib/entry/browser.js"],"names":["BrowserAdapter_1","require","adapter","default","ready","authorize","init","client","options","getSmartApi","FHIRCLIENT_PURE","fetch","window","Headers","Request","Response","FHIR","AbortController","oauth2","settings","module","exports"],"mappings":"AAAA,a,CAAc;AACd;;AAEA,MAAMA,gBAAgB,GAAGC,OAAO,CAAC,4BAAD,CAAhC;;AAEA,MAAMC,OAAO,GAAG,IAAIF,gBAAgB,CAACG,OAArB,EAAhB;AACA,MAAM;AACJC,EAAAA,KADI;AAEJC,EAAAA,SAFI;AAGJC,EAAAA,IAHI;AAIJC,EAAAA,MAJI;AAKJC,EAAAA;AALI,IAMFN,OAAO,CAACO,WAAR,EANJ,C,CAM2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA,IAAI,OAAOC,eAAP,IAA0B,WAA9B,EAA2C;AACzC,QAAMC,KAAK,GAAGV,OAAO,CAAC,aAAD,CAArB;;AAEAA,EAAAA,OAAO,CAAC,6DAAD,CAAP;;AAEA,MAAI,CAACW,MAAM,CAACD,KAAZ,EAAmB;AACjBC,IAAAA,MAAM,CAACD,KAAP,GAAeA,KAAK,CAACR,OAArB;AACAS,IAAAA,MAAM,CAACC,OAAP,GAAiBF,KAAK,CAACE,OAAvB;AACAD,IAAAA,MAAM,CAACE,OAAP,GAAiBH,KAAK,CAACG,OAAvB;AACAF,IAAAA,MAAM,CAACG,QAAP,GAAkBJ,KAAK,CAACI,QAAxB;AACD;AACF,C,CAAC;;;AAGF,MAAMC,IAAI,GAAG;AACXC,EAAAA,eAAe,EAAEL,MAAM,CAACK,eADb;AAEXV,EAAAA,MAFW;AAGXW,EAAAA,MAAM,EAAE;AACNC,IAAAA,QAAQ,EAAEX,OADJ;AAENJ,IAAAA,KAFM;AAGNC,IAAAA,SAHM;AAINC,IAAAA;AAJM;AAHG,CAAb;AAUAc,MAAM,CAACC,OAAP,GAAiBL,IAAjB,C,CAAuB","sourcesContent":["\"use strict\"; // In Browsers we create an adapter, get the SMART api from it and build the\n// global FHIR object\n\nconst BrowserAdapter_1 = require(\"../adapters/BrowserAdapter\");\n\nconst adapter = new BrowserAdapter_1.default();\nconst {\n  ready,\n  authorize,\n  init,\n  client,\n  options\n} = adapter.getSmartApi(); // We have two kinds of browser builds - \"pure\" for new browsers and \"legacy\"\n// for old ones. In pure builds we assume that the browser supports everything\n// we need. In legacy mode, the library also acts as a polyfill. Babel will\n// automatically polyfill everything except \"fetch\", which we have to handle\n// manually.\n// @ts-ignore\n\nif (typeof FHIRCLIENT_PURE == \"undefined\") {\n  const fetch = require(\"cross-fetch\");\n\n  require(\"abortcontroller-polyfill/dist/abortcontroller-polyfill-only\");\n\n  if (!window.fetch) {\n    window.fetch = fetch.default;\n    window.Headers = fetch.Headers;\n    window.Request = fetch.Request;\n    window.Response = fetch.Response;\n  }\n} // $lab:coverage:off$\n\n\nconst FHIR = {\n  AbortController: window.AbortController,\n  client,\n  oauth2: {\n    settings: options,\n    ready,\n    authorize,\n    init\n  }\n};\nmodule.exports = FHIR; // $lab:coverage:on$"]},"metadata":{},"sourceType":"script"}
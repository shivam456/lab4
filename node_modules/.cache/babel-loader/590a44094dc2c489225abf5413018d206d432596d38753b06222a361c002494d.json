{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.init = exports.buildTokenRequest = exports.ready = exports.onMessage = exports.isInPopUp = exports.isInFrame = exports.authorize = exports.getSecurityExtensions = exports.fetchWellKnownJson = exports.KEY = void 0;\n/* global window */\n\nconst lib_1 = require(\"./lib\");\nconst Client_1 = require(\"./Client\");\nconst settings_1 = require(\"./settings\");\nObject.defineProperty(exports, \"KEY\", {\n  enumerable: true,\n  get: function () {\n    return settings_1.SMART_KEY;\n  }\n});\nconst debug = lib_1.debug.extend(\"oauth2\");\nfunction isBrowser() {\n  return typeof window === \"object\";\n}\n/**\n * Fetches the well-known json file from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n */\n\nfunction fetchWellKnownJson() {\n  let baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n  let requestOptions = arguments.length > 1 ? arguments[1] : undefined;\n  const url = String(baseUrl).replace(/\\/*$/, \"/\") + \".well-known/smart-configuration\";\n  return (0, lib_1.getAndCache)(url, requestOptions).catch(ex => {\n    throw new Error(`Failed to fetch the well-known json \"${url}\". ${ex.message}`);\n  });\n}\nexports.fetchWellKnownJson = fetchWellKnownJson;\n/**\n * Fetch a \"WellKnownJson\" and extract the SMART endpoints from it\n */\n\nfunction getSecurityExtensionsFromWellKnownJson() {\n  let baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n  let requestOptions = arguments.length > 1 ? arguments[1] : undefined;\n  return fetchWellKnownJson(baseUrl, requestOptions).then(meta => {\n    if (!meta.authorization_endpoint || !meta.token_endpoint) {\n      throw new Error(\"Invalid wellKnownJson\");\n    }\n    return {\n      registrationUri: meta.registration_endpoint || \"\",\n      authorizeUri: meta.authorization_endpoint,\n      tokenUri: meta.token_endpoint,\n      codeChallengeMethods: meta.code_challenge_methods_supported || []\n    };\n  });\n}\n/**\n * Fetch a `CapabilityStatement` and extract the SMART endpoints from it\n */\n\nfunction getSecurityExtensionsFromConformanceStatement() {\n  let baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n  let requestOptions = arguments.length > 1 ? arguments[1] : undefined;\n  return (0, lib_1.fetchConformanceStatement)(baseUrl, requestOptions).then(meta => {\n    const nsUri = \"http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris\";\n    const extensions = ((0, lib_1.getPath)(meta || {}, \"rest.0.security.extension\") || []).filter(e => e.url === nsUri).map(o => o.extension)[0];\n    const out = {\n      registrationUri: \"\",\n      authorizeUri: \"\",\n      tokenUri: \"\",\n      codeChallengeMethods: []\n    };\n    if (extensions) {\n      extensions.forEach(ext => {\n        if (ext.url === \"register\") {\n          out.registrationUri = ext.valueUri;\n        }\n        if (ext.url === \"authorize\") {\n          out.authorizeUri = ext.valueUri;\n        }\n        if (ext.url === \"token\") {\n          out.tokenUri = ext.valueUri;\n        }\n      });\n    }\n    return out;\n  });\n}\n/**\n * Given a FHIR server, returns an object with it's Oauth security endpoints\n * that we are interested in. This will try to find the info in both the\n * `CapabilityStatement` and the `.well-known/smart-configuration`. Whatever\n * Arrives first will be used and the other request will be aborted.\n * @param [baseUrl = \"/\"] Fhir server base URL\n */\n\nfunction getSecurityExtensions() {\n  let baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n  return getSecurityExtensionsFromWellKnownJson(baseUrl).catch(() => getSecurityExtensionsFromConformanceStatement(baseUrl));\n}\nexports.getSecurityExtensions = getSecurityExtensions;\n/**\n * Starts the SMART Launch Sequence.\n * > **IMPORTANT**:\n *   `authorize()` will end up redirecting you to the authorization server.\n *    This means that you should not add anything to the returned promise chain.\n *    Any code written directly after the authorize() call might not be executed\n *    due to that redirect!\n * @param env\n * @param [params]\n */\n\nasync function authorize(env) {\n  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const url = env.getUrl(); // Multiple config for EHR launches ---------------------------------------\n\n  if (Array.isArray(params)) {\n    const urlISS = url.searchParams.get(\"iss\") || url.searchParams.get(\"fhirServiceUrl\");\n    if (!urlISS) {\n      throw new Error('Passing in an \"iss\" url parameter is required if authorize ' + 'uses multiple configurations');\n    } // pick the right config\n\n    const cfg = params.find(x => {\n      if (x.issMatch) {\n        if (typeof x.issMatch === \"function\") {\n          return !!x.issMatch(urlISS);\n        }\n        if (typeof x.issMatch === \"string\") {\n          return x.issMatch === urlISS;\n        }\n        if (x.issMatch instanceof RegExp) {\n          return x.issMatch.test(urlISS);\n        }\n      }\n      return false;\n    });\n    (0, lib_1.assert)(cfg, `No configuration found matching the current \"iss\" parameter \"${urlISS}\"`);\n    return await authorize(env, cfg);\n  } // ------------------------------------------------------------------------\n  // Obtain input\n\n  const {\n    redirect_uri,\n    clientSecret,\n    fakeTokenResponse,\n    patientId,\n    encounterId,\n    client_id,\n    target,\n    width,\n    height,\n    pkceMode,\n    clientPublicKeySetUrl\n  } = params;\n  let {\n    iss,\n    launch,\n    fhirServiceUrl,\n    redirectUri,\n    noRedirect,\n    scope = \"\",\n    clientId,\n    completeInTarget,\n    clientPrivateJwk\n  } = params;\n  const storage = env.getStorage(); // For these three an url param takes precedence over inline option\n\n  iss = url.searchParams.get(\"iss\") || iss;\n  fhirServiceUrl = url.searchParams.get(\"fhirServiceUrl\") || fhirServiceUrl;\n  launch = url.searchParams.get(\"launch\") || launch;\n  if (!clientId) {\n    clientId = client_id;\n  }\n  if (!redirectUri) {\n    redirectUri = redirect_uri;\n  }\n  if (!redirectUri) {\n    redirectUri = env.relative(\".\");\n  } else if (!redirectUri.match(/^https?\\:\\/\\//)) {\n    redirectUri = env.relative(redirectUri);\n  }\n  const serverUrl = String(iss || fhirServiceUrl || \"\"); // Validate input\n\n  if (!serverUrl) {\n    throw new Error(\"No server url found. It must be specified as `iss` or as \" + \"`fhirServiceUrl` parameter\");\n  }\n  if (iss) {\n    debug(\"Making %s launch...\", launch ? \"EHR\" : \"standalone\");\n  } // append launch scope if needed\n\n  if (launch && !scope.match(/launch/)) {\n    scope += \" launch\";\n  }\n  if (isBrowser()) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp();\n    if ((inFrame || inPopUp) && completeInTarget !== true && completeInTarget !== false) {\n      // completeInTarget will default to true if authorize is called from\n      // within an iframe. This is to avoid issues when the entire app\n      // happens to be rendered in an iframe (including in some EHRs),\n      // even though that was not how the app developer's intention.\n      completeInTarget = inFrame; // In this case we can't always make the best decision so ask devs\n      // to be explicit in their configuration.\n\n      console.warn('Your app is being authorized from within an iframe or popup ' + 'window. Please be explicit and provide a \"completeInTarget\" ' + 'option. Use \"true\" to complete the authorization in the ' + 'same window, or \"false\" to try to complete it in the parent ' + 'or the opener window. See http://docs.smarthealthit.org/client-js/api.html');\n    }\n  } // If `authorize` is called, make sure we clear any previous state (in case\n  // this is a re-authorize)\n\n  const oldKey = await storage.get(settings_1.SMART_KEY);\n  await storage.unset(oldKey); // create initial state\n\n  const stateKey = (0, lib_1.randomString)(16);\n  const state = {\n    clientId,\n    scope,\n    redirectUri,\n    serverUrl,\n    clientSecret,\n    clientPrivateJwk,\n    tokenResponse: {},\n    key: stateKey,\n    completeInTarget,\n    clientPublicKeySetUrl\n  };\n  const fullSessionStorageSupport = isBrowser() ? (0, lib_1.getPath)(env, \"options.fullSessionStorageSupport\") : true;\n  if (fullSessionStorageSupport) {\n    await storage.set(settings_1.SMART_KEY, stateKey);\n  } // fakeTokenResponse to override stuff (useful in development)\n\n  if (fakeTokenResponse) {\n    Object.assign(state.tokenResponse, fakeTokenResponse);\n  } // Fixed patientId (useful in development)\n\n  if (patientId) {\n    Object.assign(state.tokenResponse, {\n      patient: patientId\n    });\n  } // Fixed encounterId (useful in development)\n\n  if (encounterId) {\n    Object.assign(state.tokenResponse, {\n      encounter: encounterId\n    });\n  }\n  let redirectUrl = redirectUri + \"?state=\" + encodeURIComponent(stateKey); // bypass oauth if fhirServiceUrl is used (but iss takes precedence)\n\n  if (fhirServiceUrl && !iss) {\n    debug(\"Making fake launch...\");\n    await storage.set(stateKey, state);\n    if (noRedirect) {\n      return redirectUrl;\n    }\n    return await env.redirect(redirectUrl);\n  } // Get oauth endpoints and add them to the state\n\n  const extensions = await getSecurityExtensions(serverUrl);\n  Object.assign(state, extensions);\n  await storage.set(stateKey, state); // If this happens to be an open server and there is no authorizeUri\n\n  if (!state.authorizeUri) {\n    if (noRedirect) {\n      return redirectUrl;\n    }\n    return await env.redirect(redirectUrl);\n  } // build the redirect uri\n\n  const redirectParams = [\"response_type=code\", \"client_id=\" + encodeURIComponent(clientId || \"\"), \"scope=\" + encodeURIComponent(scope), \"redirect_uri=\" + encodeURIComponent(redirectUri), \"aud=\" + encodeURIComponent(serverUrl), \"state=\" + encodeURIComponent(stateKey)]; // also pass this in case of EHR launch\n\n  if (launch) {\n    redirectParams.push(\"launch=\" + encodeURIComponent(launch));\n  }\n  if (shouldIncludeChallenge(extensions.codeChallengeMethods.includes('S256'), pkceMode)) {\n    let codes = await env.security.generatePKCEChallenge();\n    Object.assign(state, codes);\n    await storage.set(stateKey, state);\n    redirectParams.push(\"code_challenge=\" + state.codeChallenge); // note that the challenge is ALREADY encoded properly\n\n    redirectParams.push(\"code_challenge_method=S256\");\n  }\n  redirectUrl = state.authorizeUri + \"?\" + redirectParams.join(\"&\");\n  if (noRedirect) {\n    return redirectUrl;\n  }\n  if (target && isBrowser()) {\n    let win;\n    win = await (0, lib_1.getTargetWindow)(target, width, height);\n    if (win !== self) {\n      try {\n        // Also remove any old state from the target window and then\n        // transfer the current state there\n        win.sessionStorage.removeItem(oldKey);\n        win.sessionStorage.setItem(stateKey, JSON.stringify(state));\n      } catch (ex) {\n        (0, lib_1.debug)(`Failed to modify window.sessionStorage. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        win = self;\n      }\n    }\n    if (win !== self) {\n      try {\n        win.location.href = redirectUrl;\n        self.addEventListener(\"message\", onMessage);\n      } catch (ex) {\n        (0, lib_1.debug)(`Failed to modify window.location. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        self.location.href = redirectUrl;\n      }\n    } else {\n      self.location.href = redirectUrl;\n    }\n    return;\n  } else {\n    return await env.redirect(redirectUrl);\n  }\n}\nexports.authorize = authorize;\nfunction shouldIncludeChallenge(S256supported, pkceMode) {\n  if (pkceMode === \"disabled\") {\n    return false;\n  }\n  if (pkceMode === \"unsafeV1\") {\n    return true;\n  }\n  if (pkceMode === \"required\") {\n    if (!S256supported) {\n      throw new Error(\"Required PKCE code challenge method (`S256`) was not found.\");\n    }\n    return true;\n  }\n  return S256supported;\n}\n/**\n * Checks if called within a frame. Only works in browsers!\n * If the current window has a `parent` or `top` properties that refer to\n * another window, returns true. If trying to access `top` or `parent` throws an\n * error, returns true. Otherwise returns `false`.\n */\n\nfunction isInFrame() {\n  try {\n    return self !== top && parent !== self;\n  } catch (e) {\n    return true;\n  }\n}\nexports.isInFrame = isInFrame;\n/**\n * Checks if called within another window (popup or tab). Only works in browsers!\n * To consider itself called in a new window, this function verifies that:\n * 1. `self === top` (not in frame)\n * 2. `!!opener && opener !== self` The window has an opener\n * 3. `!!window.name` The window has a `name` set\n */\n\nfunction isInPopUp() {\n  try {\n    return self === top && !!opener && opener !== self && !!window.name;\n  } catch (e) {\n    return false;\n  }\n}\nexports.isInPopUp = isInPopUp;\n/**\n * Another window can send a \"completeAuth\" message to this one, making it to\n * navigate to e.data.url\n * @param e The message event\n */\n\nfunction onMessage(e) {\n  if (e.data.type == \"completeAuth\" && e.origin === new URL(self.location.href).origin) {\n    window.removeEventListener(\"message\", onMessage);\n    window.location.href = e.data.url;\n  }\n}\nexports.onMessage = onMessage;\n/**\n * The ready function should only be called on the page that represents\n * the redirectUri. We typically land there after a redirect from the\n * authorization server, but this code will also be executed upon subsequent\n * navigation or page refresh.\n */\n\nasync function ready(env) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a, _b;\n  const url = env.getUrl();\n  const Storage = env.getStorage();\n  const params = url.searchParams;\n  let key = params.get(\"state\");\n  const code = params.get(\"code\");\n  const authError = params.get(\"error\");\n  const authErrorDescription = params.get(\"error_description\");\n  if (!key) {\n    key = await Storage.get(settings_1.SMART_KEY);\n  } // Start by checking the url for `error` and `error_description` parameters.\n  // This happens when the auth server rejects our authorization attempt. In\n  // this case it has no other way to tell us what the error was, other than\n  // appending these parameters to the redirect url.\n  // From client's point of view, this is not very reliable (because we can't\n  // know how we have landed on this page - was it a redirect or was it loaded\n  // manually). However, if `ready()` is being called, we can assume\n  // that the url comes from the auth server (otherwise the app won't work\n  // anyway).\n\n  if (authError || authErrorDescription) {\n    throw new Error([authError, authErrorDescription].filter(Boolean).join(\": \"));\n  }\n  debug(\"key: %s, code: %s\", key, code); // key might be coming from the page url so it might be empty or missing\n\n  (0, lib_1.assert)(key, \"No 'state' parameter found. Please (re)launch the app.\"); // Check if we have a previous state\n\n  let state = await Storage.get(key);\n  const fullSessionStorageSupport = isBrowser() ? (0, lib_1.getPath)(env, \"options.fullSessionStorageSupport\") : true; // If we are in a popup window or an iframe and the authorization is\n  // complete, send the location back to our opener and exit.\n\n  if (isBrowser() && state && !state.completeInTarget) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp(); // we are about to return to the opener/parent where completeAuth will\n    // be called again. In rare cases the opener or parent might also be\n    // a frame or popup. Then inFrame or inPopUp will be true but we still\n    // have to stop going up the chain. To guard against that weird form of\n    // recursion we pass one additional parameter to the url which we later\n    // remove.\n\n    if ((inFrame || inPopUp) && !url.searchParams.get(\"complete\")) {\n      url.searchParams.set(\"complete\", \"1\");\n      const {\n        href,\n        origin\n      } = url;\n      if (inFrame) {\n        parent.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n      }\n      if (inPopUp) {\n        opener.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n        window.close();\n      }\n      return new Promise(() => {});\n    }\n  }\n  url.searchParams.delete(\"complete\"); // Do we have to remove the `code` and `state` params from the URL?\n\n  const hasState = params.has(\"state\");\n  if (isBrowser() && (0, lib_1.getPath)(env, \"options.replaceBrowserHistory\") && (code || hasState)) {\n    // `code` is the flag that tell us to request an access token.\n    // We have to remove it, otherwise the page will authorize on\n    // every load!\n    if (code) {\n      params.delete(\"code\");\n      debug(\"Removed code parameter from the url.\");\n    } // If we have `fullSessionStorageSupport` it means we no longer\n    // need the `state` key. It will be stored to a well know\n    // location - sessionStorage[SMART_KEY]. However, no\n    // fullSessionStorageSupport means that this \"well know location\"\n    // might be shared between windows and tabs. In this case we\n    // MUST keep the `state` url parameter.\n\n    if (hasState && fullSessionStorageSupport) {\n      params.delete(\"state\");\n      debug(\"Removed state parameter from the url.\");\n    } // If the browser does not support the replaceState method for the\n    // History Web API, the \"code\" parameter cannot be removed. As a\n    // consequence, the page will (re)authorize on every load. The\n    // workaround is to reload the page to new location without those\n    // parameters. If that is not acceptable replaceBrowserHistory\n    // should be set to false.\n\n    if (window.history.replaceState) {\n      window.history.replaceState({}, \"\", url.href);\n    }\n  } // If the state does not exist, it means the page has been loaded directly.\n\n  (0, lib_1.assert)(state, \"No state found! Please (re)launch the app.\"); // Assume the client has already completed a token exchange when\n  // there is no code (but we have a state) or access token is found in state\n\n  const authorized = !code || ((_a = state.tokenResponse) === null || _a === void 0 ? void 0 : _a.access_token); // If we are authorized already, then this is just a reload.\n  // Otherwise, we have to complete the code flow\n\n  if (!authorized && state.tokenUri) {\n    (0, lib_1.assert)(code, \"'code' url parameter is required\");\n    debug(\"Preparing to exchange the code for access token...\");\n    const requestOptions = await buildTokenRequest(env, {\n      code,\n      state,\n      clientPublicKeySetUrl: options.clientPublicKeySetUrl,\n      privateKey: options.privateKey || state.clientPrivateJwk\n    });\n    debug(\"Token request options: %O\", requestOptions); // The EHR authorization server SHALL return a JSON structure that\n    // includes an access token or a message indicating that the\n    // authorization request has been denied.\n\n    const tokenResponse = await (0, lib_1.request)(state.tokenUri, requestOptions);\n    debug(\"Token response: %O\", tokenResponse);\n    (0, lib_1.assert)(tokenResponse.access_token, \"Failed to obtain access token.\"); // Now we need to determine when is this authorization going to expire\n\n    state.expiresAt = (0, lib_1.getAccessTokenExpiration)(tokenResponse, env); // save the tokenResponse so that we don't have to re-authorize on\n    // every page reload\n\n    state = Object.assign(Object.assign({}, state), {\n      tokenResponse\n    });\n    await Storage.set(key, state);\n    debug(\"Authorization successful!\");\n  } else {\n    debug(((_b = state.tokenResponse) === null || _b === void 0 ? void 0 : _b.access_token) ? \"Already authorized\" : \"No authorization needed\");\n  }\n  if (fullSessionStorageSupport) {\n    await Storage.set(settings_1.SMART_KEY, key);\n  }\n  const client = new Client_1.default(env, state);\n  debug(\"Created client instance: %O\", client);\n  return client;\n}\nexports.ready = ready;\n/**\n * Builds the token request options. Does not make the request, just\n * creates it's configuration and returns it in a Promise.\n */\n\nasync function buildTokenRequest(env, _ref) {\n  let {\n    code,\n    state,\n    clientPublicKeySetUrl,\n    privateKey\n  } = _ref;\n  const {\n    redirectUri,\n    clientSecret,\n    tokenUri,\n    clientId,\n    codeVerifier\n  } = state;\n  (0, lib_1.assert)(redirectUri, \"Missing state.redirectUri\");\n  (0, lib_1.assert)(tokenUri, \"Missing state.tokenUri\");\n  (0, lib_1.assert)(clientId, \"Missing state.clientId\");\n  const requestOptions = {\n    method: \"POST\",\n    headers: {\n      \"content-type\": \"application/x-www-form-urlencoded\"\n    },\n    body: `code=${code}&grant_type=authorization_code&redirect_uri=${encodeURIComponent(redirectUri)}`\n  }; // For public apps, authentication is not possible (and thus not required),\n  // since a client with no secret cannot prove its identity when it issues a\n  // call. (The end-to-end system can still be secure because the client comes\n  // from a known, https protected endpoint specified and enforced by the\n  // redirect uri.) For confidential apps, an Authorization header using HTTP\n  // Basic authentication is required, where the username is the app’s\n  // client_id and the password is the app’s client_secret (see example).\n\n  if (clientSecret) {\n    requestOptions.headers.authorization = \"Basic \" + env.btoa(clientId + \":\" + clientSecret);\n    debug(\"Using state.clientSecret to construct the authorization header: %s\", requestOptions.headers.authorization);\n  } // Asymmetric auth\n  else if (privateKey) {\n    const pk = \"key\" in privateKey ? privateKey.key : await env.security.importJWK(privateKey);\n    const jwtHeaders = {\n      typ: \"JWT\",\n      kid: privateKey.kid,\n      jku: clientPublicKeySetUrl || state.clientPublicKeySetUrl\n    };\n    const jwtClaims = {\n      iss: clientId,\n      sub: clientId,\n      aud: tokenUri,\n      jti: env.base64urlencode(env.security.randomBytes(32)),\n      exp: (0, lib_1.getTimeInFuture)(120) // two minutes in the future\n    };\n\n    const clientAssertion = await env.security.signCompactJws(privateKey.alg, pk, jwtHeaders, jwtClaims);\n    requestOptions.body += `&client_assertion_type=${encodeURIComponent(\"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\")}`;\n    requestOptions.body += `&client_assertion=${encodeURIComponent(clientAssertion)}`;\n    debug(\"Using state.clientPrivateJwk to add a client_assertion to the POST body\");\n  } // Public client\n  else {\n    debug(\"Public client detected; adding state.clientId to the POST body\");\n    requestOptions.body += `&client_id=${encodeURIComponent(clientId)}`;\n  }\n  if (codeVerifier) {\n    debug(\"Found state.codeVerifier, adding to the POST body\"); // Note that the codeVerifier is ALREADY encoded properly  \n\n    requestOptions.body += \"&code_verifier=\" + codeVerifier;\n  }\n  return requestOptions;\n}\nexports.buildTokenRequest = buildTokenRequest;\n/**\n * This function can be used when you want to handle everything in one page\n * (no launch endpoint needed). You can think of it as if it does:\n * ```js\n * authorize(options).then(ready)\n * ```\n *\n * **Be careful with init()!** There are some details you need to be aware of:\n *\n * 1. It will only work if your launch_uri is the same as your redirect_uri.\n *    While this should be valid, we can’t promise that every EHR will allow you\n *    to register client with such settings.\n * 2. Internally, `init()` will be called twice. First it will redirect to the\n *    EHR, then the EHR will redirect back to the page where init() will be\n *    called again to complete the authorization. This is generally fine,\n *    because the returned promise will only be resolved once, after the second\n *    execution, but please also consider the following:\n *    - You should wrap all your app’s code in a function that is only executed\n *      after `init()` resolves!\n *    - Since the page will be loaded twice, you must be careful if your code\n *      has global side effects that can persist between page reloads\n *      (for example writing to localStorage).\n * 3. For standalone launch, only use init in combination with offline_access\n *    scope. Once the access_token expires, if you don’t have a refresh_token\n *    there is no way to re-authorize properly. We detect that and delete the\n *    expired access token, but it still means that the user will have to\n *    refresh the page twice to re-authorize.\n * @param env The adapter\n * @param authorizeOptions The authorize options\n */\n\nasync function init(env, authorizeOptions, readyOptions) {\n  const url = env.getUrl();\n  const code = url.searchParams.get(\"code\");\n  const state = url.searchParams.get(\"state\"); // if `code` and `state` params are present we need to complete the auth flow\n\n  if (code && state) {\n    return ready(env, readyOptions);\n  } // Check for existing client state. If state is found, it means a client\n  // instance have already been created in this session and we should try to\n  // \"revive\" it.\n\n  const storage = env.getStorage();\n  const key = state || (await storage.get(settings_1.SMART_KEY));\n  const cached = await storage.get(key);\n  if (cached) {\n    return new Client_1.default(env, cached);\n  } // Otherwise try to launch\n\n  return authorize(env, authorizeOptions).then(() => {\n    // `init` promises a Client but that cannot happen in this case. The\n    // browser will be redirected (unload the page and be redirected back\n    // to it later and the same init function will be called again). On\n    // success, authorize will resolve with the redirect url but we don't\n    // want to return that from this promise chain because it is not a\n    // Client instance. At the same time, if authorize fails, we do want to\n    // pass the error to those waiting for a client instance.\n    return new Promise(() => {});\n  });\n}\nexports.init = init;","map":{"version":3,"names":["Object","defineProperty","exports","value","init","buildTokenRequest","ready","onMessage","isInPopUp","isInFrame","authorize","getSecurityExtensions","fetchWellKnownJson","KEY","lib_1","require","Client_1","settings_1","enumerable","get","SMART_KEY","debug","extend","isBrowser","window","baseUrl","requestOptions","url","String","replace","getAndCache","catch","ex","Error","message","getSecurityExtensionsFromWellKnownJson","then","meta","authorization_endpoint","token_endpoint","registrationUri","registration_endpoint","authorizeUri","tokenUri","codeChallengeMethods","code_challenge_methods_supported","getSecurityExtensionsFromConformanceStatement","fetchConformanceStatement","nsUri","extensions","getPath","filter","e","map","o","extension","out","forEach","ext","valueUri","env","params","getUrl","Array","isArray","urlISS","searchParams","cfg","find","x","issMatch","RegExp","test","assert","redirect_uri","clientSecret","fakeTokenResponse","patientId","encounterId","client_id","target","width","height","pkceMode","clientPublicKeySetUrl","iss","launch","fhirServiceUrl","redirectUri","noRedirect","scope","clientId","completeInTarget","clientPrivateJwk","storage","getStorage","relative","match","serverUrl","inFrame","inPopUp","console","warn","oldKey","unset","stateKey","randomString","state","tokenResponse","key","fullSessionStorageSupport","set","assign","patient","encounter","redirectUrl","encodeURIComponent","redirect","redirectParams","push","shouldIncludeChallenge","includes","codes","security","generatePKCEChallenge","codeChallenge","join","win","getTargetWindow","self","sessionStorage","removeItem","setItem","JSON","stringify","location","href","addEventListener","S256supported","top","parent","opener","name","data","type","origin","URL","removeEventListener","options","_a","_b","Storage","code","authError","authErrorDescription","Boolean","postMessage","close","Promise","delete","hasState","has","history","replaceState","authorized","access_token","privateKey","request","expiresAt","getAccessTokenExpiration","client","default","codeVerifier","method","headers","body","authorization","btoa","pk","importJWK","jwtHeaders","typ","kid","jku","jwtClaims","sub","aud","jti","base64urlencode","randomBytes","exp","getTimeInFuture","clientAssertion","signCompactJws","alg","authorizeOptions","readyOptions","cached"],"sources":["/Users/shivamrustogi/Documents/GitHub/lab4/node_modules/fhirclient/lib/smart.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.init = exports.buildTokenRequest = exports.ready = exports.onMessage = exports.isInPopUp = exports.isInFrame = exports.authorize = exports.getSecurityExtensions = exports.fetchWellKnownJson = exports.KEY = void 0;\n/* global window */\n\nconst lib_1 = require(\"./lib\");\n\nconst Client_1 = require(\"./Client\");\n\nconst settings_1 = require(\"./settings\");\n\nObject.defineProperty(exports, \"KEY\", {\n  enumerable: true,\n  get: function () {\n    return settings_1.SMART_KEY;\n  }\n});\nconst debug = lib_1.debug.extend(\"oauth2\");\n\nfunction isBrowser() {\n  return typeof window === \"object\";\n}\n/**\n * Fetches the well-known json file from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n */\n\n\nfunction fetchWellKnownJson(baseUrl = \"/\", requestOptions) {\n  const url = String(baseUrl).replace(/\\/*$/, \"/\") + \".well-known/smart-configuration\";\n  return (0, lib_1.getAndCache)(url, requestOptions).catch(ex => {\n    throw new Error(`Failed to fetch the well-known json \"${url}\". ${ex.message}`);\n  });\n}\n\nexports.fetchWellKnownJson = fetchWellKnownJson;\n/**\n * Fetch a \"WellKnownJson\" and extract the SMART endpoints from it\n */\n\nfunction getSecurityExtensionsFromWellKnownJson(baseUrl = \"/\", requestOptions) {\n  return fetchWellKnownJson(baseUrl, requestOptions).then(meta => {\n    if (!meta.authorization_endpoint || !meta.token_endpoint) {\n      throw new Error(\"Invalid wellKnownJson\");\n    }\n\n    return {\n      registrationUri: meta.registration_endpoint || \"\",\n      authorizeUri: meta.authorization_endpoint,\n      tokenUri: meta.token_endpoint,\n      codeChallengeMethods: meta.code_challenge_methods_supported || []\n    };\n  });\n}\n/**\n * Fetch a `CapabilityStatement` and extract the SMART endpoints from it\n */\n\n\nfunction getSecurityExtensionsFromConformanceStatement(baseUrl = \"/\", requestOptions) {\n  return (0, lib_1.fetchConformanceStatement)(baseUrl, requestOptions).then(meta => {\n    const nsUri = \"http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris\";\n    const extensions = ((0, lib_1.getPath)(meta || {}, \"rest.0.security.extension\") || []).filter(e => e.url === nsUri).map(o => o.extension)[0];\n    const out = {\n      registrationUri: \"\",\n      authorizeUri: \"\",\n      tokenUri: \"\",\n      codeChallengeMethods: []\n    };\n\n    if (extensions) {\n      extensions.forEach(ext => {\n        if (ext.url === \"register\") {\n          out.registrationUri = ext.valueUri;\n        }\n\n        if (ext.url === \"authorize\") {\n          out.authorizeUri = ext.valueUri;\n        }\n\n        if (ext.url === \"token\") {\n          out.tokenUri = ext.valueUri;\n        }\n      });\n    }\n\n    return out;\n  });\n}\n/**\n * Given a FHIR server, returns an object with it's Oauth security endpoints\n * that we are interested in. This will try to find the info in both the\n * `CapabilityStatement` and the `.well-known/smart-configuration`. Whatever\n * Arrives first will be used and the other request will be aborted.\n * @param [baseUrl = \"/\"] Fhir server base URL\n */\n\n\nfunction getSecurityExtensions(baseUrl = \"/\") {\n  return getSecurityExtensionsFromWellKnownJson(baseUrl).catch(() => getSecurityExtensionsFromConformanceStatement(baseUrl));\n}\n\nexports.getSecurityExtensions = getSecurityExtensions;\n/**\n * Starts the SMART Launch Sequence.\n * > **IMPORTANT**:\n *   `authorize()` will end up redirecting you to the authorization server.\n *    This means that you should not add anything to the returned promise chain.\n *    Any code written directly after the authorize() call might not be executed\n *    due to that redirect!\n * @param env\n * @param [params]\n */\n\nasync function authorize(env, params = {}) {\n  const url = env.getUrl(); // Multiple config for EHR launches ---------------------------------------\n\n  if (Array.isArray(params)) {\n    const urlISS = url.searchParams.get(\"iss\") || url.searchParams.get(\"fhirServiceUrl\");\n\n    if (!urlISS) {\n      throw new Error('Passing in an \"iss\" url parameter is required if authorize ' + 'uses multiple configurations');\n    } // pick the right config\n\n\n    const cfg = params.find(x => {\n      if (x.issMatch) {\n        if (typeof x.issMatch === \"function\") {\n          return !!x.issMatch(urlISS);\n        }\n\n        if (typeof x.issMatch === \"string\") {\n          return x.issMatch === urlISS;\n        }\n\n        if (x.issMatch instanceof RegExp) {\n          return x.issMatch.test(urlISS);\n        }\n      }\n\n      return false;\n    });\n    (0, lib_1.assert)(cfg, `No configuration found matching the current \"iss\" parameter \"${urlISS}\"`);\n    return await authorize(env, cfg);\n  } // ------------------------------------------------------------------------\n  // Obtain input\n\n\n  const {\n    redirect_uri,\n    clientSecret,\n    fakeTokenResponse,\n    patientId,\n    encounterId,\n    client_id,\n    target,\n    width,\n    height,\n    pkceMode,\n    clientPublicKeySetUrl\n  } = params;\n  let {\n    iss,\n    launch,\n    fhirServiceUrl,\n    redirectUri,\n    noRedirect,\n    scope = \"\",\n    clientId,\n    completeInTarget,\n    clientPrivateJwk\n  } = params;\n  const storage = env.getStorage(); // For these three an url param takes precedence over inline option\n\n  iss = url.searchParams.get(\"iss\") || iss;\n  fhirServiceUrl = url.searchParams.get(\"fhirServiceUrl\") || fhirServiceUrl;\n  launch = url.searchParams.get(\"launch\") || launch;\n\n  if (!clientId) {\n    clientId = client_id;\n  }\n\n  if (!redirectUri) {\n    redirectUri = redirect_uri;\n  }\n\n  if (!redirectUri) {\n    redirectUri = env.relative(\".\");\n  } else if (!redirectUri.match(/^https?\\:\\/\\//)) {\n    redirectUri = env.relative(redirectUri);\n  }\n\n  const serverUrl = String(iss || fhirServiceUrl || \"\"); // Validate input\n\n  if (!serverUrl) {\n    throw new Error(\"No server url found. It must be specified as `iss` or as \" + \"`fhirServiceUrl` parameter\");\n  }\n\n  if (iss) {\n    debug(\"Making %s launch...\", launch ? \"EHR\" : \"standalone\");\n  } // append launch scope if needed\n\n\n  if (launch && !scope.match(/launch/)) {\n    scope += \" launch\";\n  }\n\n  if (isBrowser()) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp();\n\n    if ((inFrame || inPopUp) && completeInTarget !== true && completeInTarget !== false) {\n      // completeInTarget will default to true if authorize is called from\n      // within an iframe. This is to avoid issues when the entire app\n      // happens to be rendered in an iframe (including in some EHRs),\n      // even though that was not how the app developer's intention.\n      completeInTarget = inFrame; // In this case we can't always make the best decision so ask devs\n      // to be explicit in their configuration.\n\n      console.warn('Your app is being authorized from within an iframe or popup ' + 'window. Please be explicit and provide a \"completeInTarget\" ' + 'option. Use \"true\" to complete the authorization in the ' + 'same window, or \"false\" to try to complete it in the parent ' + 'or the opener window. See http://docs.smarthealthit.org/client-js/api.html');\n    }\n  } // If `authorize` is called, make sure we clear any previous state (in case\n  // this is a re-authorize)\n\n\n  const oldKey = await storage.get(settings_1.SMART_KEY);\n  await storage.unset(oldKey); // create initial state\n\n  const stateKey = (0, lib_1.randomString)(16);\n  const state = {\n    clientId,\n    scope,\n    redirectUri,\n    serverUrl,\n    clientSecret,\n    clientPrivateJwk,\n    tokenResponse: {},\n    key: stateKey,\n    completeInTarget,\n    clientPublicKeySetUrl\n  };\n  const fullSessionStorageSupport = isBrowser() ? (0, lib_1.getPath)(env, \"options.fullSessionStorageSupport\") : true;\n\n  if (fullSessionStorageSupport) {\n    await storage.set(settings_1.SMART_KEY, stateKey);\n  } // fakeTokenResponse to override stuff (useful in development)\n\n\n  if (fakeTokenResponse) {\n    Object.assign(state.tokenResponse, fakeTokenResponse);\n  } // Fixed patientId (useful in development)\n\n\n  if (patientId) {\n    Object.assign(state.tokenResponse, {\n      patient: patientId\n    });\n  } // Fixed encounterId (useful in development)\n\n\n  if (encounterId) {\n    Object.assign(state.tokenResponse, {\n      encounter: encounterId\n    });\n  }\n\n  let redirectUrl = redirectUri + \"?state=\" + encodeURIComponent(stateKey); // bypass oauth if fhirServiceUrl is used (but iss takes precedence)\n\n  if (fhirServiceUrl && !iss) {\n    debug(\"Making fake launch...\");\n    await storage.set(stateKey, state);\n\n    if (noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // Get oauth endpoints and add them to the state\n\n\n  const extensions = await getSecurityExtensions(serverUrl);\n  Object.assign(state, extensions);\n  await storage.set(stateKey, state); // If this happens to be an open server and there is no authorizeUri\n\n  if (!state.authorizeUri) {\n    if (noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // build the redirect uri\n\n\n  const redirectParams = [\"response_type=code\", \"client_id=\" + encodeURIComponent(clientId || \"\"), \"scope=\" + encodeURIComponent(scope), \"redirect_uri=\" + encodeURIComponent(redirectUri), \"aud=\" + encodeURIComponent(serverUrl), \"state=\" + encodeURIComponent(stateKey)]; // also pass this in case of EHR launch\n\n  if (launch) {\n    redirectParams.push(\"launch=\" + encodeURIComponent(launch));\n  }\n\n  if (shouldIncludeChallenge(extensions.codeChallengeMethods.includes('S256'), pkceMode)) {\n    let codes = await env.security.generatePKCEChallenge();\n    Object.assign(state, codes);\n    await storage.set(stateKey, state);\n    redirectParams.push(\"code_challenge=\" + state.codeChallenge); // note that the challenge is ALREADY encoded properly\n\n    redirectParams.push(\"code_challenge_method=S256\");\n  }\n\n  redirectUrl = state.authorizeUri + \"?\" + redirectParams.join(\"&\");\n\n  if (noRedirect) {\n    return redirectUrl;\n  }\n\n  if (target && isBrowser()) {\n    let win;\n    win = await (0, lib_1.getTargetWindow)(target, width, height);\n\n    if (win !== self) {\n      try {\n        // Also remove any old state from the target window and then\n        // transfer the current state there\n        win.sessionStorage.removeItem(oldKey);\n        win.sessionStorage.setItem(stateKey, JSON.stringify(state));\n      } catch (ex) {\n        (0, lib_1.debug)(`Failed to modify window.sessionStorage. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        win = self;\n      }\n    }\n\n    if (win !== self) {\n      try {\n        win.location.href = redirectUrl;\n        self.addEventListener(\"message\", onMessage);\n      } catch (ex) {\n        (0, lib_1.debug)(`Failed to modify window.location. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        self.location.href = redirectUrl;\n      }\n    } else {\n      self.location.href = redirectUrl;\n    }\n\n    return;\n  } else {\n    return await env.redirect(redirectUrl);\n  }\n}\n\nexports.authorize = authorize;\n\nfunction shouldIncludeChallenge(S256supported, pkceMode) {\n  if (pkceMode === \"disabled\") {\n    return false;\n  }\n\n  if (pkceMode === \"unsafeV1\") {\n    return true;\n  }\n\n  if (pkceMode === \"required\") {\n    if (!S256supported) {\n      throw new Error(\"Required PKCE code challenge method (`S256`) was not found.\");\n    }\n\n    return true;\n  }\n\n  return S256supported;\n}\n/**\n * Checks if called within a frame. Only works in browsers!\n * If the current window has a `parent` or `top` properties that refer to\n * another window, returns true. If trying to access `top` or `parent` throws an\n * error, returns true. Otherwise returns `false`.\n */\n\n\nfunction isInFrame() {\n  try {\n    return self !== top && parent !== self;\n  } catch (e) {\n    return true;\n  }\n}\n\nexports.isInFrame = isInFrame;\n/**\n * Checks if called within another window (popup or tab). Only works in browsers!\n * To consider itself called in a new window, this function verifies that:\n * 1. `self === top` (not in frame)\n * 2. `!!opener && opener !== self` The window has an opener\n * 3. `!!window.name` The window has a `name` set\n */\n\nfunction isInPopUp() {\n  try {\n    return self === top && !!opener && opener !== self && !!window.name;\n  } catch (e) {\n    return false;\n  }\n}\n\nexports.isInPopUp = isInPopUp;\n/**\n * Another window can send a \"completeAuth\" message to this one, making it to\n * navigate to e.data.url\n * @param e The message event\n */\n\nfunction onMessage(e) {\n  if (e.data.type == \"completeAuth\" && e.origin === new URL(self.location.href).origin) {\n    window.removeEventListener(\"message\", onMessage);\n    window.location.href = e.data.url;\n  }\n}\n\nexports.onMessage = onMessage;\n/**\n * The ready function should only be called on the page that represents\n * the redirectUri. We typically land there after a redirect from the\n * authorization server, but this code will also be executed upon subsequent\n * navigation or page refresh.\n */\n\nasync function ready(env, options = {}) {\n  var _a, _b;\n\n  const url = env.getUrl();\n  const Storage = env.getStorage();\n  const params = url.searchParams;\n  let key = params.get(\"state\");\n  const code = params.get(\"code\");\n  const authError = params.get(\"error\");\n  const authErrorDescription = params.get(\"error_description\");\n\n  if (!key) {\n    key = await Storage.get(settings_1.SMART_KEY);\n  } // Start by checking the url for `error` and `error_description` parameters.\n  // This happens when the auth server rejects our authorization attempt. In\n  // this case it has no other way to tell us what the error was, other than\n  // appending these parameters to the redirect url.\n  // From client's point of view, this is not very reliable (because we can't\n  // know how we have landed on this page - was it a redirect or was it loaded\n  // manually). However, if `ready()` is being called, we can assume\n  // that the url comes from the auth server (otherwise the app won't work\n  // anyway).\n\n\n  if (authError || authErrorDescription) {\n    throw new Error([authError, authErrorDescription].filter(Boolean).join(\": \"));\n  }\n\n  debug(\"key: %s, code: %s\", key, code); // key might be coming from the page url so it might be empty or missing\n\n  (0, lib_1.assert)(key, \"No 'state' parameter found. Please (re)launch the app.\"); // Check if we have a previous state\n\n  let state = await Storage.get(key);\n  const fullSessionStorageSupport = isBrowser() ? (0, lib_1.getPath)(env, \"options.fullSessionStorageSupport\") : true; // If we are in a popup window or an iframe and the authorization is\n  // complete, send the location back to our opener and exit.\n\n  if (isBrowser() && state && !state.completeInTarget) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp(); // we are about to return to the opener/parent where completeAuth will\n    // be called again. In rare cases the opener or parent might also be\n    // a frame or popup. Then inFrame or inPopUp will be true but we still\n    // have to stop going up the chain. To guard against that weird form of\n    // recursion we pass one additional parameter to the url which we later\n    // remove.\n\n    if ((inFrame || inPopUp) && !url.searchParams.get(\"complete\")) {\n      url.searchParams.set(\"complete\", \"1\");\n      const {\n        href,\n        origin\n      } = url;\n\n      if (inFrame) {\n        parent.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n      }\n\n      if (inPopUp) {\n        opener.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n        window.close();\n      }\n\n      return new Promise(() => {});\n    }\n  }\n\n  url.searchParams.delete(\"complete\"); // Do we have to remove the `code` and `state` params from the URL?\n\n  const hasState = params.has(\"state\");\n\n  if (isBrowser() && (0, lib_1.getPath)(env, \"options.replaceBrowserHistory\") && (code || hasState)) {\n    // `code` is the flag that tell us to request an access token.\n    // We have to remove it, otherwise the page will authorize on\n    // every load!\n    if (code) {\n      params.delete(\"code\");\n      debug(\"Removed code parameter from the url.\");\n    } // If we have `fullSessionStorageSupport` it means we no longer\n    // need the `state` key. It will be stored to a well know\n    // location - sessionStorage[SMART_KEY]. However, no\n    // fullSessionStorageSupport means that this \"well know location\"\n    // might be shared between windows and tabs. In this case we\n    // MUST keep the `state` url parameter.\n\n\n    if (hasState && fullSessionStorageSupport) {\n      params.delete(\"state\");\n      debug(\"Removed state parameter from the url.\");\n    } // If the browser does not support the replaceState method for the\n    // History Web API, the \"code\" parameter cannot be removed. As a\n    // consequence, the page will (re)authorize on every load. The\n    // workaround is to reload the page to new location without those\n    // parameters. If that is not acceptable replaceBrowserHistory\n    // should be set to false.\n\n\n    if (window.history.replaceState) {\n      window.history.replaceState({}, \"\", url.href);\n    }\n  } // If the state does not exist, it means the page has been loaded directly.\n\n\n  (0, lib_1.assert)(state, \"No state found! Please (re)launch the app.\"); // Assume the client has already completed a token exchange when\n  // there is no code (but we have a state) or access token is found in state\n\n  const authorized = !code || ((_a = state.tokenResponse) === null || _a === void 0 ? void 0 : _a.access_token); // If we are authorized already, then this is just a reload.\n  // Otherwise, we have to complete the code flow\n\n  if (!authorized && state.tokenUri) {\n    (0, lib_1.assert)(code, \"'code' url parameter is required\");\n    debug(\"Preparing to exchange the code for access token...\");\n    const requestOptions = await buildTokenRequest(env, {\n      code,\n      state,\n      clientPublicKeySetUrl: options.clientPublicKeySetUrl,\n      privateKey: options.privateKey || state.clientPrivateJwk\n    });\n    debug(\"Token request options: %O\", requestOptions); // The EHR authorization server SHALL return a JSON structure that\n    // includes an access token or a message indicating that the\n    // authorization request has been denied.\n\n    const tokenResponse = await (0, lib_1.request)(state.tokenUri, requestOptions);\n    debug(\"Token response: %O\", tokenResponse);\n    (0, lib_1.assert)(tokenResponse.access_token, \"Failed to obtain access token.\"); // Now we need to determine when is this authorization going to expire\n\n    state.expiresAt = (0, lib_1.getAccessTokenExpiration)(tokenResponse, env); // save the tokenResponse so that we don't have to re-authorize on\n    // every page reload\n\n    state = Object.assign(Object.assign({}, state), {\n      tokenResponse\n    });\n    await Storage.set(key, state);\n    debug(\"Authorization successful!\");\n  } else {\n    debug(((_b = state.tokenResponse) === null || _b === void 0 ? void 0 : _b.access_token) ? \"Already authorized\" : \"No authorization needed\");\n  }\n\n  if (fullSessionStorageSupport) {\n    await Storage.set(settings_1.SMART_KEY, key);\n  }\n\n  const client = new Client_1.default(env, state);\n  debug(\"Created client instance: %O\", client);\n  return client;\n}\n\nexports.ready = ready;\n/**\n * Builds the token request options. Does not make the request, just\n * creates it's configuration and returns it in a Promise.\n */\n\nasync function buildTokenRequest(env, {\n  code,\n  state,\n  clientPublicKeySetUrl,\n  privateKey\n}) {\n  const {\n    redirectUri,\n    clientSecret,\n    tokenUri,\n    clientId,\n    codeVerifier\n  } = state;\n  (0, lib_1.assert)(redirectUri, \"Missing state.redirectUri\");\n  (0, lib_1.assert)(tokenUri, \"Missing state.tokenUri\");\n  (0, lib_1.assert)(clientId, \"Missing state.clientId\");\n  const requestOptions = {\n    method: \"POST\",\n    headers: {\n      \"content-type\": \"application/x-www-form-urlencoded\"\n    },\n    body: `code=${code}&grant_type=authorization_code&redirect_uri=${encodeURIComponent(redirectUri)}`\n  }; // For public apps, authentication is not possible (and thus not required),\n  // since a client with no secret cannot prove its identity when it issues a\n  // call. (The end-to-end system can still be secure because the client comes\n  // from a known, https protected endpoint specified and enforced by the\n  // redirect uri.) For confidential apps, an Authorization header using HTTP\n  // Basic authentication is required, where the username is the app’s\n  // client_id and the password is the app’s client_secret (see example).\n\n  if (clientSecret) {\n    requestOptions.headers.authorization = \"Basic \" + env.btoa(clientId + \":\" + clientSecret);\n    debug(\"Using state.clientSecret to construct the authorization header: %s\", requestOptions.headers.authorization);\n  } // Asymmetric auth\n  else if (privateKey) {\n    const pk = \"key\" in privateKey ? privateKey.key : await env.security.importJWK(privateKey);\n    const jwtHeaders = {\n      typ: \"JWT\",\n      kid: privateKey.kid,\n      jku: clientPublicKeySetUrl || state.clientPublicKeySetUrl\n    };\n    const jwtClaims = {\n      iss: clientId,\n      sub: clientId,\n      aud: tokenUri,\n      jti: env.base64urlencode(env.security.randomBytes(32)),\n      exp: (0, lib_1.getTimeInFuture)(120) // two minutes in the future\n\n    };\n    const clientAssertion = await env.security.signCompactJws(privateKey.alg, pk, jwtHeaders, jwtClaims);\n    requestOptions.body += `&client_assertion_type=${encodeURIComponent(\"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\")}`;\n    requestOptions.body += `&client_assertion=${encodeURIComponent(clientAssertion)}`;\n    debug(\"Using state.clientPrivateJwk to add a client_assertion to the POST body\");\n  } // Public client\n  else {\n    debug(\"Public client detected; adding state.clientId to the POST body\");\n    requestOptions.body += `&client_id=${encodeURIComponent(clientId)}`;\n  }\n\n  if (codeVerifier) {\n    debug(\"Found state.codeVerifier, adding to the POST body\"); // Note that the codeVerifier is ALREADY encoded properly  \n\n    requestOptions.body += \"&code_verifier=\" + codeVerifier;\n  }\n\n  return requestOptions;\n}\n\nexports.buildTokenRequest = buildTokenRequest;\n/**\n * This function can be used when you want to handle everything in one page\n * (no launch endpoint needed). You can think of it as if it does:\n * ```js\n * authorize(options).then(ready)\n * ```\n *\n * **Be careful with init()!** There are some details you need to be aware of:\n *\n * 1. It will only work if your launch_uri is the same as your redirect_uri.\n *    While this should be valid, we can’t promise that every EHR will allow you\n *    to register client with such settings.\n * 2. Internally, `init()` will be called twice. First it will redirect to the\n *    EHR, then the EHR will redirect back to the page where init() will be\n *    called again to complete the authorization. This is generally fine,\n *    because the returned promise will only be resolved once, after the second\n *    execution, but please also consider the following:\n *    - You should wrap all your app’s code in a function that is only executed\n *      after `init()` resolves!\n *    - Since the page will be loaded twice, you must be careful if your code\n *      has global side effects that can persist between page reloads\n *      (for example writing to localStorage).\n * 3. For standalone launch, only use init in combination with offline_access\n *    scope. Once the access_token expires, if you don’t have a refresh_token\n *    there is no way to re-authorize properly. We detect that and delete the\n *    expired access token, but it still means that the user will have to\n *    refresh the page twice to re-authorize.\n * @param env The adapter\n * @param authorizeOptions The authorize options\n */\n\nasync function init(env, authorizeOptions, readyOptions) {\n  const url = env.getUrl();\n  const code = url.searchParams.get(\"code\");\n  const state = url.searchParams.get(\"state\"); // if `code` and `state` params are present we need to complete the auth flow\n\n  if (code && state) {\n    return ready(env, readyOptions);\n  } // Check for existing client state. If state is found, it means a client\n  // instance have already been created in this session and we should try to\n  // \"revive\" it.\n\n\n  const storage = env.getStorage();\n  const key = state || (await storage.get(settings_1.SMART_KEY));\n  const cached = await storage.get(key);\n\n  if (cached) {\n    return new Client_1.default(env, cached);\n  } // Otherwise try to launch\n\n\n  return authorize(env, authorizeOptions).then(() => {\n    // `init` promises a Client but that cannot happen in this case. The\n    // browser will be redirected (unload the page and be redirected back\n    // to it later and the same init function will be called again). On\n    // success, authorize will resolve with the redirect url but we don't\n    // want to return that from this promise chain because it is not a\n    // Client instance. At the same time, if authorize fails, we do want to\n    // pass the error to those waiting for a client instance.\n    return new Promise(() => {});\n  });\n}\n\nexports.init = init;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
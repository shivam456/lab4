{"ast":null,"code":"\"use strict\";\n\n/*\n * This file contains some shared functions. They are used by other modules, but\n * are defined here so that tests can import this library and test them.\n */\nvar __rest = void 0 && (void 0).__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertJsonPatch = exports.assert = exports.getTargetWindow = exports.getPatientParam = exports.byCodes = exports.byCode = exports.getAccessTokenExpiration = exports.getTimeInFuture = exports.jwtDecode = exports.randomString = exports.absolute = exports.makeArray = exports.setPath = exports.getPath = exports.fetchConformanceStatement = exports.getAndCache = exports.request = exports.loweCaseKeys = exports.responseToJSON = exports.checkResponse = exports.units = exports.debug = void 0;\nconst HttpError_1 = require(\"./HttpError\");\nconst settings_1 = require(\"./settings\");\nconst debug = require(\"debug\"); // $lab:coverage:off$\n// @ts-ignore\n\nconst {\n  fetch\n} = typeof FHIRCLIENT_PURE !== \"undefined\" ? window : require(\"cross-fetch\"); // $lab:coverage:on$\n\nconst _debug = debug(\"FHIR\");\nexports.debug = _debug;\n/**\n * The cache for the `getAndCache` function\n */\n\nconst cache = {};\n/**\n * A namespace with functions for converting between different measurement units\n */\n\nexports.units = {\n  cm(_ref) {\n    let {\n      code,\n      value\n    } = _ref;\n    ensureNumerical({\n      code,\n      value\n    });\n    if (code == \"cm\") return value;\n    if (code == \"m\") return value * 100;\n    if (code == \"in\") return value * 2.54;\n    if (code == \"[in_us]\") return value * 2.54;\n    if (code == \"[in_i]\") return value * 2.54;\n    if (code == \"ft\") return value * 30.48;\n    if (code == \"[ft_us]\") return value * 30.48;\n    throw new Error(\"Unrecognized length unit: \" + code);\n  },\n  kg(_ref2) {\n    let {\n      code,\n      value\n    } = _ref2;\n    ensureNumerical({\n      code,\n      value\n    });\n    if (code == \"kg\") return value;\n    if (code == \"g\") return value / 1000;\n    if (code.match(/lb/)) return value / 2.20462;\n    if (code.match(/oz/)) return value / 35.274;\n    throw new Error(\"Unrecognized weight unit: \" + code);\n  },\n  any(pq) {\n    ensureNumerical(pq);\n    return pq.value;\n  }\n};\n/**\n * Assertion function to guard arguments for `units` functions\n */\n\nfunction ensureNumerical(_ref3) {\n  let {\n    value,\n    code\n  } = _ref3;\n  if (typeof value !== \"number\") {\n    throw new Error(\"Found a non-numerical unit: \" + value + \" \" + code);\n  }\n}\n/**\n * Used in fetch Promise chains to reject if the \"ok\" property is not true\n */\n\nasync function checkResponse(resp) {\n  if (!resp.ok) {\n    const error = new HttpError_1.default(resp);\n    await error.parse();\n    throw error;\n  }\n  return resp;\n}\nexports.checkResponse = checkResponse;\n/**\n * Used in fetch Promise chains to return the JSON version of the response.\n * Note that `resp.json()` will throw on empty body so we use resp.text()\n * instead.\n */\n\nfunction responseToJSON(resp) {\n  return resp.text().then(text => text.length ? JSON.parse(text) : \"\");\n}\nexports.responseToJSON = responseToJSON;\nfunction loweCaseKeys(obj) {\n  // Can be undefined to signal that this key should be removed\n  if (!obj) {\n    return obj;\n  } // Arrays are valid values in case of recursive calls\n\n  if (Array.isArray(obj)) {\n    return obj.map(v => v && typeof v === \"object\" ? loweCaseKeys(v) : v);\n  } // Plain object\n\n  let out = {};\n  Object.keys(obj).forEach(key => {\n    const lowerKey = key.toLowerCase();\n    const v = obj[key];\n    out[lowerKey] = v && typeof v == \"object\" ? loweCaseKeys(v) : v;\n  });\n  return out;\n}\nexports.loweCaseKeys = loweCaseKeys;\n/**\n * This is our built-in request function. It does a few things by default\n * (unless told otherwise):\n * - Makes CORS requests\n * - Sets accept header to \"application/json\"\n * - Handles errors\n * - If the response is json return the json object\n * - If the response is text return the result text\n * - Otherwise return the response object on which we call stuff like `.blob()`\n */\n\nfunction request(url) {\n  let requestOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n      includeResponse\n    } = requestOptions,\n    options = __rest(requestOptions, [\"includeResponse\"]);\n  return fetch(url, Object.assign(Object.assign({\n    mode: \"cors\"\n  }, options), {\n    headers: Object.assign({\n      accept: \"application/json\"\n    }, loweCaseKeys(options.headers))\n  })).then(checkResponse).then(res => {\n    const type = res.headers.get(\"content-type\") + \"\";\n    if (type.match(/\\bjson\\b/i)) {\n      return responseToJSON(res).then(body => ({\n        res,\n        body\n      }));\n    }\n    if (type.match(/^text\\//i)) {\n      return res.text().then(body => ({\n        res,\n        body\n      }));\n    }\n    return {\n      res\n    };\n  }).then(_ref4 => {\n    let {\n      res,\n      body\n    } = _ref4;\n    // Some servers will reply after CREATE with json content type but with\n    // empty body. In this case check if a location header is received and\n    // fetch that to use it as the final result.\n    if (!body && res.status == 201) {\n      const location = res.headers.get(\"location\");\n      if (location) {\n        return request(location, Object.assign(Object.assign({}, options), {\n          method: \"GET\",\n          body: null,\n          includeResponse\n        }));\n      }\n    }\n    if (includeResponse) {\n      return {\n        body,\n        response: res\n      };\n    } // For any non-text and non-json response return the Response object.\n    // This to let users decide if they want to call text(), blob() or\n    // something else on it\n\n    if (body === undefined) {\n      return res;\n    } // Otherwise just return the parsed body (can also be \"\" or null)\n\n    return body;\n  });\n}\nexports.request = request;\n/**\n * Makes a request using `fetch` and stores the result in internal memory cache.\n * The cache is cleared when the page is unloaded.\n * @param url The URL to request\n * @param requestOptions Request options\n * @param force If true, reload from source and update the cache, even if it has\n * already been cached.\n */\n\nfunction getAndCache(url, requestOptions) {\n  let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.env.NODE_ENV === \"test\";\n  if (force || !cache[url]) {\n    cache[url] = request(url, requestOptions);\n    return cache[url];\n  }\n  return Promise.resolve(cache[url]);\n}\nexports.getAndCache = getAndCache;\n/**\n * Fetches the conformance statement from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n * @param [requestOptions] Any options passed to the fetch call\n */\n\nfunction fetchConformanceStatement() {\n  let baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n  let requestOptions = arguments.length > 1 ? arguments[1] : undefined;\n  const url = String(baseUrl).replace(/\\/*$/, \"/\") + \"metadata\";\n  return getAndCache(url, requestOptions).catch(ex => {\n    throw new Error(`Failed to fetch the conformance statement from \"${url}\". ${ex}`);\n  });\n}\nexports.fetchConformanceStatement = fetchConformanceStatement;\n/**\n * Walks through an object (or array) and returns the value found at the\n * provided path. This function is very simple so it intentionally does not\n * support any argument polymorphism, meaning that the path can only be a\n * dot-separated string. If the path is invalid returns undefined.\n * @param obj The object (or Array) to walk through\n * @param path The path (eg. \"a.b.4.c\")\n * @returns {*} Whatever is found in the path or undefined\n */\n\nfunction getPath(obj) {\n  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  path = path.trim();\n  if (!path) {\n    return obj;\n  }\n  let segments = path.split(\".\");\n  let result = obj;\n  while (result && segments.length) {\n    const key = segments.shift();\n    if (!key && Array.isArray(result)) {\n      return result.map(o => getPath(o, segments.join(\".\")));\n    } else {\n      result = result[key];\n    }\n  }\n  return result;\n}\nexports.getPath = getPath;\n/**\n * Like getPath, but if the node is found, its value is set to @value\n * @param obj The object (or Array) to walk through\n * @param path The path (eg. \"a.b.4.c\")\n * @param value The value to set\n * @param createEmpty If true, create missing intermediate objects or arrays\n * @returns The modified object\n */\n\nfunction setPath(obj, path, value) {\n  let createEmpty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  path.trim().split(\".\").reduce((out, key, idx, arr) => {\n    if (out && idx === arr.length - 1) {\n      out[key] = value;\n    } else {\n      if (out && out[key] === undefined && createEmpty) {\n        out[key] = arr[idx + 1].match(/^[0-9]+$/) ? [] : {};\n      }\n      return out ? out[key] : undefined;\n    }\n  }, obj);\n  return obj;\n}\nexports.setPath = setPath;\n/**\n * If the argument is an array returns it as is. Otherwise puts it in an array\n * (`[arg]`) and returns the result\n * @param arg The element to test and possibly convert to array\n * @category Utility\n */\n\nfunction makeArray(arg) {\n  if (Array.isArray(arg)) {\n    return arg;\n  }\n  return [arg];\n}\nexports.makeArray = makeArray;\n/**\n * Given a path, converts it to absolute url based on the `baseUrl`. If baseUrl\n * is not provided, the result would be a rooted path (one that starts with `/`).\n * @param path The path to convert\n * @param baseUrl The base URL\n */\n\nfunction absolute(path, baseUrl) {\n  if (path.match(/^http/)) return path;\n  if (path.match(/^urn/)) return path;\n  return String(baseUrl || \"\").replace(/\\/+$/, \"\") + \"/\" + path.replace(/^\\/+/, \"\");\n}\nexports.absolute = absolute;\n/**\n * Generates random strings. By default this returns random 8 characters long\n * alphanumeric strings.\n * @param strLength The length of the output string. Defaults to 8.\n * @param charSet A string containing all the possible characters.\n *     Defaults to all the upper and lower-case letters plus digits.\n * @category Utility\n */\n\nfunction randomString() {\n  let strLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n  let charSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const result = [];\n  const len = charSet.length;\n  while (strLength--) {\n    result.push(charSet.charAt(Math.floor(Math.random() * len)));\n  }\n  return result.join(\"\");\n}\nexports.randomString = randomString;\n/**\n * Decodes a JWT token and returns it's body.\n * @param token The token to read\n * @param env An `Adapter` or any other object that has an `atob` method\n * @category Utility\n */\n\nfunction jwtDecode(token, env) {\n  const payload = token.split(\".\")[1];\n  return payload ? JSON.parse(env.atob(payload)) : null;\n}\nexports.jwtDecode = jwtDecode;\n/**\n * Add a supplied number of seconds to the supplied Date, returning\n * an integer number of seconds since the epoch\n * @param secondsAhead How far ahead, in seconds (defaults to 120 seconds)\n * @param from Initial time (defaults to current time)\n */\n\nfunction getTimeInFuture() {\n  let secondsAhead = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 120;\n  let from = arguments.length > 1 ? arguments[1] : undefined;\n  return Math.floor(+(from || new Date()) / 1000 + secondsAhead);\n}\nexports.getTimeInFuture = getTimeInFuture;\n/**\n * Given a token response, computes and returns the expiresAt timestamp.\n * Note that this should only be used immediately after an access token is\n * received, otherwise the computed timestamp will be incorrect.\n * @param tokenResponse\n * @param env\n */\n\nfunction getAccessTokenExpiration(tokenResponse, env) {\n  const now = Math.floor(Date.now() / 1000); // Option 1 - using the expires_in property of the token response\n\n  if (tokenResponse.expires_in) {\n    return now + tokenResponse.expires_in;\n  } // Option 2 - using the exp property of JWT tokens (must not assume JWT!)\n\n  if (tokenResponse.access_token) {\n    let tokenBody = jwtDecode(tokenResponse.access_token, env);\n    if (tokenBody && tokenBody.exp) {\n      return tokenBody.exp;\n    }\n  } // Option 3 - if none of the above worked set this to 5 minutes after now\n\n  return now + 300;\n}\nexports.getAccessTokenExpiration = getAccessTokenExpiration;\n/**\n * Groups the observations by code. Returns a map that will look like:\n * ```js\n * const map = client.byCodes(observations, \"code\");\n * // map = {\n * //     \"55284-4\": [ observation1, observation2 ],\n * //     \"6082-2\": [ observation3 ]\n * // }\n * ```\n * @param observations Array of observations\n * @param property The name of a CodeableConcept property to group by\n */\n\nfunction byCode(observations, property) {\n  const ret = {};\n  function handleCodeableConcept(concept, observation) {\n    if (concept && Array.isArray(concept.coding)) {\n      concept.coding.forEach(_ref5 => {\n        let {\n          code\n        } = _ref5;\n        if (code) {\n          ret[code] = ret[code] || [];\n          ret[code].push(observation);\n        }\n      });\n    }\n  }\n  makeArray(observations).forEach(o => {\n    if (o.resourceType === \"Observation\" && o[property]) {\n      if (Array.isArray(o[property])) {\n        o[property].forEach(concept => handleCodeableConcept(concept, o));\n      } else {\n        handleCodeableConcept(o[property], o);\n      }\n    }\n  });\n  return ret;\n}\nexports.byCode = byCode;\n/**\n * First groups the observations by code using `byCode`. Then returns a function\n * that accepts codes as arguments and will return a flat array of observations\n * having that codes. Example:\n * ```js\n * const filter = client.byCodes(observations, \"category\");\n * filter(\"laboratory\") // => [ observation1, observation2 ]\n * filter(\"vital-signs\") // => [ observation3 ]\n * filter(\"laboratory\", \"vital-signs\") // => [ observation1, observation2, observation3 ]\n * ```\n * @param observations Array of observations\n * @param property The name of a CodeableConcept property to group by\n */\n\nfunction byCodes(observations, property) {\n  const bank = byCode(observations, property);\n  return function () {\n    for (var _len = arguments.length, codes = new Array(_len), _key = 0; _key < _len; _key++) {\n      codes[_key] = arguments[_key];\n    }\n    return codes.filter(code => code + \"\" in bank).reduce((prev, code) => prev.concat(bank[code + \"\"]), []);\n  };\n}\nexports.byCodes = byCodes;\n/**\n * Given a conformance statement and a resource type, returns the name of the\n * URL parameter that can be used to scope the resource type by patient ID.\n */\n\nfunction getPatientParam(conformance, resourceType) {\n  // Find what resources are supported by this server\n  const resources = getPath(conformance, \"rest.0.resource\") || []; // Check if this resource is supported\n\n  const meta = resources.find(r => r.type === resourceType);\n  if (!meta) {\n    throw new Error(`Resource \"${resourceType}\" is not supported by this FHIR server`);\n  } // Check if any search parameters are available for this resource\n\n  if (!Array.isArray(meta.searchParam)) {\n    throw new Error(`No search parameters supported for \"${resourceType}\" on this FHIR server`);\n  } // This is a rare case but could happen in generic workflows\n\n  if (resourceType == \"Patient\" && meta.searchParam.find(x => x.name == \"_id\")) {\n    return \"_id\";\n  } // Now find the first possible parameter name\n\n  const out = settings_1.patientParams.find(p => meta.searchParam.find(x => x.name == p)); // If there is no match\n\n  if (!out) {\n    throw new Error(\"I don't know what param to use for \" + resourceType);\n  }\n  return out;\n}\nexports.getPatientParam = getPatientParam;\n/**\n * Resolves a reference to target window. It may also open new window or tab if\n * the `target = \"popup\"` or `target = \"_blank\"`.\n * @param target\n * @param width Only used when `target = \"popup\"`\n * @param height Only used when `target = \"popup\"`\n */\n\nasync function getTargetWindow(target) {\n  let width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 800;\n  let height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 720;\n  // The target can be a function that returns the target. This can be\n  // used to open a layer pop-up with an iframe and then return a reference\n  // to that iframe (or its name)\n  if (typeof target == \"function\") {\n    target = await target();\n  } // The target can be a window reference\n\n  if (target && typeof target == \"object\") {\n    return target;\n  } // At this point target must be a string\n\n  if (typeof target != \"string\") {\n    _debug(\"Invalid target type '%s'. Failing back to '_self'.\", typeof target);\n    return self;\n  } // Current window\n\n  if (target == \"_self\") {\n    return self;\n  } // The parent frame\n\n  if (target == \"_parent\") {\n    return parent;\n  } // The top window\n\n  if (target == \"_top\") {\n    return top || self;\n  } // New tab or window\n\n  if (target == \"_blank\") {\n    let error,\n      targetWindow = null;\n    try {\n      targetWindow = window.open(\"\", \"SMARTAuthPopup\");\n      if (!targetWindow) {\n        throw new Error(\"Perhaps window.open was blocked\");\n      }\n    } catch (e) {\n      error = e;\n    }\n    if (!targetWindow) {\n      _debug(\"Cannot open window. Failing back to '_self'. %s\", error);\n      return self;\n    } else {\n      return targetWindow;\n    }\n  } // Popup window\n\n  if (target == \"popup\") {\n    let error,\n      targetWindow = null; // if (!targetWindow || targetWindow.closed) {\n\n    try {\n      targetWindow = window.open(\"\", \"SMARTAuthPopup\", [\"height=\" + height, \"width=\" + width, \"menubar=0\", \"resizable=1\", \"status=0\", \"top=\" + (screen.height - height) / 2, \"left=\" + (screen.width - width) / 2].join(\",\"));\n      if (!targetWindow) {\n        throw new Error(\"Perhaps the popup window was blocked\");\n      }\n    } catch (e) {\n      error = e;\n    }\n    if (!targetWindow) {\n      _debug(\"Cannot open window. Failing back to '_self'. %s\", error);\n      return self;\n    } else {\n      return targetWindow;\n    }\n  } // Frame or window by name\n\n  const winOrFrame = frames[target];\n  if (winOrFrame) {\n    return winOrFrame;\n  }\n  _debug(\"Unknown target '%s'. Failing back to '_self'.\", target);\n  return self;\n}\nexports.getTargetWindow = getTargetWindow;\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\nexports.assert = assert;\nfunction assertJsonPatch(patch) {\n  assert(Array.isArray(patch), \"The JSON patch must be an array\");\n  assert(patch.length > 0, \"The JSON patch array should not be empty\");\n  patch.forEach(operation => {\n    assert([\"add\", \"replace\", \"test\", \"move\", \"copy\", \"remove\"].indexOf(operation.op) > -1, 'Each patch operation must have an \"op\" property which must be one of: \"add\", \"replace\", \"test\", \"move\", \"copy\", \"remove\"');\n    assert(operation.path && typeof operation.path, `Invalid \"${operation.op}\" operation. Missing \"path\" property`);\n    if (operation.op == \"add\" || operation.op == \"replace\" || operation.op == \"test\") {\n      assert(\"value\" in operation, `Invalid \"${operation.op}\" operation. Missing \"value\" property`);\n      assert(Object.keys(operation).length == 3, `Invalid \"${operation.op}\" operation. Contains unknown properties`);\n    } else if (operation.op == \"move\" || operation.op == \"copy\") {\n      assert(typeof operation.from == \"string\", `Invalid \"${operation.op}\" operation. Requires a string \"from\" property`);\n      assert(Object.keys(operation).length == 3, `Invalid \"${operation.op}\" operation. Contains unknown properties`);\n    } else {\n      assert(Object.keys(operation).length == 2, `Invalid \"${operation.op}\" operation. Contains unknown properties`);\n    }\n  });\n}\nexports.assertJsonPatch = assertJsonPatch;","map":{"version":3,"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","defineProperty","exports","value","assertJsonPatch","assert","getTargetWindow","getPatientParam","byCodes","byCode","getAccessTokenExpiration","getTimeInFuture","jwtDecode","randomString","absolute","makeArray","setPath","getPath","fetchConformanceStatement","getAndCache","request","loweCaseKeys","responseToJSON","checkResponse","units","debug","HttpError_1","require","settings_1","fetch","FHIRCLIENT_PURE","window","_debug","cache","cm","code","ensureNumerical","Error","kg","match","any","pq","resp","ok","error","default","parse","text","then","JSON","obj","Array","isArray","map","v","out","keys","forEach","key","lowerKey","toLowerCase","url","requestOptions","includeResponse","options","assign","mode","headers","accept","res","type","get","body","status","location","method","response","undefined","force","process","env","NODE_ENV","Promise","resolve","baseUrl","String","replace","catch","ex","path","trim","segments","split","result","shift","o","join","createEmpty","reduce","idx","arr","arg","strLength","charSet","len","push","charAt","Math","floor","random","token","payload","atob","secondsAhead","from","Date","tokenResponse","now","expires_in","access_token","tokenBody","exp","observations","property","ret","handleCodeableConcept","concept","observation","coding","resourceType","bank","codes","filter","prev","concat","conformance","resources","meta","find","r","searchParam","x","name","patientParams","target","width","height","self","parent","top","targetWindow","open","screen","winOrFrame","frames","condition","message","patch","operation","op"],"sources":["/Users/shivamrustogi/Documents/GitHub/lab4/node_modules/fhirclient/lib/lib.js"],"sourcesContent":["\"use strict\";\n/*\n * This file contains some shared functions. They are used by other modules, but\n * are defined here so that tests can import this library and test them.\n */\n\nvar __rest = void 0 && (void 0).__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertJsonPatch = exports.assert = exports.getTargetWindow = exports.getPatientParam = exports.byCodes = exports.byCode = exports.getAccessTokenExpiration = exports.getTimeInFuture = exports.jwtDecode = exports.randomString = exports.absolute = exports.makeArray = exports.setPath = exports.getPath = exports.fetchConformanceStatement = exports.getAndCache = exports.request = exports.loweCaseKeys = exports.responseToJSON = exports.checkResponse = exports.units = exports.debug = void 0;\n\nconst HttpError_1 = require(\"./HttpError\");\n\nconst settings_1 = require(\"./settings\");\n\nconst debug = require(\"debug\"); // $lab:coverage:off$\n// @ts-ignore\n\n\nconst {\n  fetch\n} = typeof FHIRCLIENT_PURE !== \"undefined\" ? window : require(\"cross-fetch\"); // $lab:coverage:on$\n\nconst _debug = debug(\"FHIR\");\n\nexports.debug = _debug;\n/**\n * The cache for the `getAndCache` function\n */\n\nconst cache = {};\n/**\n * A namespace with functions for converting between different measurement units\n */\n\nexports.units = {\n  cm({\n    code,\n    value\n  }) {\n    ensureNumerical({\n      code,\n      value\n    });\n    if (code == \"cm\") return value;\n    if (code == \"m\") return value * 100;\n    if (code == \"in\") return value * 2.54;\n    if (code == \"[in_us]\") return value * 2.54;\n    if (code == \"[in_i]\") return value * 2.54;\n    if (code == \"ft\") return value * 30.48;\n    if (code == \"[ft_us]\") return value * 30.48;\n    throw new Error(\"Unrecognized length unit: \" + code);\n  },\n\n  kg({\n    code,\n    value\n  }) {\n    ensureNumerical({\n      code,\n      value\n    });\n    if (code == \"kg\") return value;\n    if (code == \"g\") return value / 1000;\n    if (code.match(/lb/)) return value / 2.20462;\n    if (code.match(/oz/)) return value / 35.274;\n    throw new Error(\"Unrecognized weight unit: \" + code);\n  },\n\n  any(pq) {\n    ensureNumerical(pq);\n    return pq.value;\n  }\n\n};\n/**\n * Assertion function to guard arguments for `units` functions\n */\n\nfunction ensureNumerical({\n  value,\n  code\n}) {\n  if (typeof value !== \"number\") {\n    throw new Error(\"Found a non-numerical unit: \" + value + \" \" + code);\n  }\n}\n/**\n * Used in fetch Promise chains to reject if the \"ok\" property is not true\n */\n\n\nasync function checkResponse(resp) {\n  if (!resp.ok) {\n    const error = new HttpError_1.default(resp);\n    await error.parse();\n    throw error;\n  }\n\n  return resp;\n}\n\nexports.checkResponse = checkResponse;\n/**\n * Used in fetch Promise chains to return the JSON version of the response.\n * Note that `resp.json()` will throw on empty body so we use resp.text()\n * instead.\n */\n\nfunction responseToJSON(resp) {\n  return resp.text().then(text => text.length ? JSON.parse(text) : \"\");\n}\n\nexports.responseToJSON = responseToJSON;\n\nfunction loweCaseKeys(obj) {\n  // Can be undefined to signal that this key should be removed\n  if (!obj) {\n    return obj;\n  } // Arrays are valid values in case of recursive calls\n\n\n  if (Array.isArray(obj)) {\n    return obj.map(v => v && typeof v === \"object\" ? loweCaseKeys(v) : v);\n  } // Plain object\n\n\n  let out = {};\n  Object.keys(obj).forEach(key => {\n    const lowerKey = key.toLowerCase();\n    const v = obj[key];\n    out[lowerKey] = v && typeof v == \"object\" ? loweCaseKeys(v) : v;\n  });\n  return out;\n}\n\nexports.loweCaseKeys = loweCaseKeys;\n/**\n * This is our built-in request function. It does a few things by default\n * (unless told otherwise):\n * - Makes CORS requests\n * - Sets accept header to \"application/json\"\n * - Handles errors\n * - If the response is json return the json object\n * - If the response is text return the result text\n * - Otherwise return the response object on which we call stuff like `.blob()`\n */\n\nfunction request(url, requestOptions = {}) {\n  const {\n    includeResponse\n  } = requestOptions,\n        options = __rest(requestOptions, [\"includeResponse\"]);\n\n  return fetch(url, Object.assign(Object.assign({\n    mode: \"cors\"\n  }, options), {\n    headers: Object.assign({\n      accept: \"application/json\"\n    }, loweCaseKeys(options.headers))\n  })).then(checkResponse).then(res => {\n    const type = res.headers.get(\"content-type\") + \"\";\n\n    if (type.match(/\\bjson\\b/i)) {\n      return responseToJSON(res).then(body => ({\n        res,\n        body\n      }));\n    }\n\n    if (type.match(/^text\\//i)) {\n      return res.text().then(body => ({\n        res,\n        body\n      }));\n    }\n\n    return {\n      res\n    };\n  }).then(({\n    res,\n    body\n  }) => {\n    // Some servers will reply after CREATE with json content type but with\n    // empty body. In this case check if a location header is received and\n    // fetch that to use it as the final result.\n    if (!body && res.status == 201) {\n      const location = res.headers.get(\"location\");\n\n      if (location) {\n        return request(location, Object.assign(Object.assign({}, options), {\n          method: \"GET\",\n          body: null,\n          includeResponse\n        }));\n      }\n    }\n\n    if (includeResponse) {\n      return {\n        body,\n        response: res\n      };\n    } // For any non-text and non-json response return the Response object.\n    // This to let users decide if they want to call text(), blob() or\n    // something else on it\n\n\n    if (body === undefined) {\n      return res;\n    } // Otherwise just return the parsed body (can also be \"\" or null)\n\n\n    return body;\n  });\n}\n\nexports.request = request;\n/**\n * Makes a request using `fetch` and stores the result in internal memory cache.\n * The cache is cleared when the page is unloaded.\n * @param url The URL to request\n * @param requestOptions Request options\n * @param force If true, reload from source and update the cache, even if it has\n * already been cached.\n */\n\nfunction getAndCache(url, requestOptions, force = process.env.NODE_ENV === \"test\") {\n  if (force || !cache[url]) {\n    cache[url] = request(url, requestOptions);\n    return cache[url];\n  }\n\n  return Promise.resolve(cache[url]);\n}\n\nexports.getAndCache = getAndCache;\n/**\n * Fetches the conformance statement from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n * @param [requestOptions] Any options passed to the fetch call\n */\n\nfunction fetchConformanceStatement(baseUrl = \"/\", requestOptions) {\n  const url = String(baseUrl).replace(/\\/*$/, \"/\") + \"metadata\";\n  return getAndCache(url, requestOptions).catch(ex => {\n    throw new Error(`Failed to fetch the conformance statement from \"${url}\". ${ex}`);\n  });\n}\n\nexports.fetchConformanceStatement = fetchConformanceStatement;\n/**\n * Walks through an object (or array) and returns the value found at the\n * provided path. This function is very simple so it intentionally does not\n * support any argument polymorphism, meaning that the path can only be a\n * dot-separated string. If the path is invalid returns undefined.\n * @param obj The object (or Array) to walk through\n * @param path The path (eg. \"a.b.4.c\")\n * @returns {*} Whatever is found in the path or undefined\n */\n\nfunction getPath(obj, path = \"\") {\n  path = path.trim();\n\n  if (!path) {\n    return obj;\n  }\n\n  let segments = path.split(\".\");\n  let result = obj;\n\n  while (result && segments.length) {\n    const key = segments.shift();\n\n    if (!key && Array.isArray(result)) {\n      return result.map(o => getPath(o, segments.join(\".\")));\n    } else {\n      result = result[key];\n    }\n  }\n\n  return result;\n}\n\nexports.getPath = getPath;\n/**\n * Like getPath, but if the node is found, its value is set to @value\n * @param obj The object (or Array) to walk through\n * @param path The path (eg. \"a.b.4.c\")\n * @param value The value to set\n * @param createEmpty If true, create missing intermediate objects or arrays\n * @returns The modified object\n */\n\nfunction setPath(obj, path, value, createEmpty = false) {\n  path.trim().split(\".\").reduce((out, key, idx, arr) => {\n    if (out && idx === arr.length - 1) {\n      out[key] = value;\n    } else {\n      if (out && out[key] === undefined && createEmpty) {\n        out[key] = arr[idx + 1].match(/^[0-9]+$/) ? [] : {};\n      }\n\n      return out ? out[key] : undefined;\n    }\n  }, obj);\n  return obj;\n}\n\nexports.setPath = setPath;\n/**\n * If the argument is an array returns it as is. Otherwise puts it in an array\n * (`[arg]`) and returns the result\n * @param arg The element to test and possibly convert to array\n * @category Utility\n */\n\nfunction makeArray(arg) {\n  if (Array.isArray(arg)) {\n    return arg;\n  }\n\n  return [arg];\n}\n\nexports.makeArray = makeArray;\n/**\n * Given a path, converts it to absolute url based on the `baseUrl`. If baseUrl\n * is not provided, the result would be a rooted path (one that starts with `/`).\n * @param path The path to convert\n * @param baseUrl The base URL\n */\n\nfunction absolute(path, baseUrl) {\n  if (path.match(/^http/)) return path;\n  if (path.match(/^urn/)) return path;\n  return String(baseUrl || \"\").replace(/\\/+$/, \"\") + \"/\" + path.replace(/^\\/+/, \"\");\n}\n\nexports.absolute = absolute;\n/**\n * Generates random strings. By default this returns random 8 characters long\n * alphanumeric strings.\n * @param strLength The length of the output string. Defaults to 8.\n * @param charSet A string containing all the possible characters.\n *     Defaults to all the upper and lower-case letters plus digits.\n * @category Utility\n */\n\nfunction randomString(strLength = 8, charSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\") {\n  const result = [];\n  const len = charSet.length;\n\n  while (strLength--) {\n    result.push(charSet.charAt(Math.floor(Math.random() * len)));\n  }\n\n  return result.join(\"\");\n}\n\nexports.randomString = randomString;\n/**\n * Decodes a JWT token and returns it's body.\n * @param token The token to read\n * @param env An `Adapter` or any other object that has an `atob` method\n * @category Utility\n */\n\nfunction jwtDecode(token, env) {\n  const payload = token.split(\".\")[1];\n  return payload ? JSON.parse(env.atob(payload)) : null;\n}\n\nexports.jwtDecode = jwtDecode;\n/**\n * Add a supplied number of seconds to the supplied Date, returning\n * an integer number of seconds since the epoch\n * @param secondsAhead How far ahead, in seconds (defaults to 120 seconds)\n * @param from Initial time (defaults to current time)\n */\n\nfunction getTimeInFuture(secondsAhead = 120, from) {\n  return Math.floor(+(from || new Date()) / 1000 + secondsAhead);\n}\n\nexports.getTimeInFuture = getTimeInFuture;\n/**\n * Given a token response, computes and returns the expiresAt timestamp.\n * Note that this should only be used immediately after an access token is\n * received, otherwise the computed timestamp will be incorrect.\n * @param tokenResponse\n * @param env\n */\n\nfunction getAccessTokenExpiration(tokenResponse, env) {\n  const now = Math.floor(Date.now() / 1000); // Option 1 - using the expires_in property of the token response\n\n  if (tokenResponse.expires_in) {\n    return now + tokenResponse.expires_in;\n  } // Option 2 - using the exp property of JWT tokens (must not assume JWT!)\n\n\n  if (tokenResponse.access_token) {\n    let tokenBody = jwtDecode(tokenResponse.access_token, env);\n\n    if (tokenBody && tokenBody.exp) {\n      return tokenBody.exp;\n    }\n  } // Option 3 - if none of the above worked set this to 5 minutes after now\n\n\n  return now + 300;\n}\n\nexports.getAccessTokenExpiration = getAccessTokenExpiration;\n/**\n * Groups the observations by code. Returns a map that will look like:\n * ```js\n * const map = client.byCodes(observations, \"code\");\n * // map = {\n * //     \"55284-4\": [ observation1, observation2 ],\n * //     \"6082-2\": [ observation3 ]\n * // }\n * ```\n * @param observations Array of observations\n * @param property The name of a CodeableConcept property to group by\n */\n\nfunction byCode(observations, property) {\n  const ret = {};\n\n  function handleCodeableConcept(concept, observation) {\n    if (concept && Array.isArray(concept.coding)) {\n      concept.coding.forEach(({\n        code\n      }) => {\n        if (code) {\n          ret[code] = ret[code] || [];\n          ret[code].push(observation);\n        }\n      });\n    }\n  }\n\n  makeArray(observations).forEach(o => {\n    if (o.resourceType === \"Observation\" && o[property]) {\n      if (Array.isArray(o[property])) {\n        o[property].forEach(concept => handleCodeableConcept(concept, o));\n      } else {\n        handleCodeableConcept(o[property], o);\n      }\n    }\n  });\n  return ret;\n}\n\nexports.byCode = byCode;\n/**\n * First groups the observations by code using `byCode`. Then returns a function\n * that accepts codes as arguments and will return a flat array of observations\n * having that codes. Example:\n * ```js\n * const filter = client.byCodes(observations, \"category\");\n * filter(\"laboratory\") // => [ observation1, observation2 ]\n * filter(\"vital-signs\") // => [ observation3 ]\n * filter(\"laboratory\", \"vital-signs\") // => [ observation1, observation2, observation3 ]\n * ```\n * @param observations Array of observations\n * @param property The name of a CodeableConcept property to group by\n */\n\nfunction byCodes(observations, property) {\n  const bank = byCode(observations, property);\n  return (...codes) => codes.filter(code => code + \"\" in bank).reduce((prev, code) => prev.concat(bank[code + \"\"]), []);\n}\n\nexports.byCodes = byCodes;\n/**\n * Given a conformance statement and a resource type, returns the name of the\n * URL parameter that can be used to scope the resource type by patient ID.\n */\n\nfunction getPatientParam(conformance, resourceType) {\n  // Find what resources are supported by this server\n  const resources = getPath(conformance, \"rest.0.resource\") || []; // Check if this resource is supported\n\n  const meta = resources.find(r => r.type === resourceType);\n\n  if (!meta) {\n    throw new Error(`Resource \"${resourceType}\" is not supported by this FHIR server`);\n  } // Check if any search parameters are available for this resource\n\n\n  if (!Array.isArray(meta.searchParam)) {\n    throw new Error(`No search parameters supported for \"${resourceType}\" on this FHIR server`);\n  } // This is a rare case but could happen in generic workflows\n\n\n  if (resourceType == \"Patient\" && meta.searchParam.find(x => x.name == \"_id\")) {\n    return \"_id\";\n  } // Now find the first possible parameter name\n\n\n  const out = settings_1.patientParams.find(p => meta.searchParam.find(x => x.name == p)); // If there is no match\n\n  if (!out) {\n    throw new Error(\"I don't know what param to use for \" + resourceType);\n  }\n\n  return out;\n}\n\nexports.getPatientParam = getPatientParam;\n/**\n * Resolves a reference to target window. It may also open new window or tab if\n * the `target = \"popup\"` or `target = \"_blank\"`.\n * @param target\n * @param width Only used when `target = \"popup\"`\n * @param height Only used when `target = \"popup\"`\n */\n\nasync function getTargetWindow(target, width = 800, height = 720) {\n  // The target can be a function that returns the target. This can be\n  // used to open a layer pop-up with an iframe and then return a reference\n  // to that iframe (or its name)\n  if (typeof target == \"function\") {\n    target = await target();\n  } // The target can be a window reference\n\n\n  if (target && typeof target == \"object\") {\n    return target;\n  } // At this point target must be a string\n\n\n  if (typeof target != \"string\") {\n    _debug(\"Invalid target type '%s'. Failing back to '_self'.\", typeof target);\n\n    return self;\n  } // Current window\n\n\n  if (target == \"_self\") {\n    return self;\n  } // The parent frame\n\n\n  if (target == \"_parent\") {\n    return parent;\n  } // The top window\n\n\n  if (target == \"_top\") {\n    return top || self;\n  } // New tab or window\n\n\n  if (target == \"_blank\") {\n    let error,\n        targetWindow = null;\n\n    try {\n      targetWindow = window.open(\"\", \"SMARTAuthPopup\");\n\n      if (!targetWindow) {\n        throw new Error(\"Perhaps window.open was blocked\");\n      }\n    } catch (e) {\n      error = e;\n    }\n\n    if (!targetWindow) {\n      _debug(\"Cannot open window. Failing back to '_self'. %s\", error);\n\n      return self;\n    } else {\n      return targetWindow;\n    }\n  } // Popup window\n\n\n  if (target == \"popup\") {\n    let error,\n        targetWindow = null; // if (!targetWindow || targetWindow.closed) {\n\n    try {\n      targetWindow = window.open(\"\", \"SMARTAuthPopup\", [\"height=\" + height, \"width=\" + width, \"menubar=0\", \"resizable=1\", \"status=0\", \"top=\" + (screen.height - height) / 2, \"left=\" + (screen.width - width) / 2].join(\",\"));\n\n      if (!targetWindow) {\n        throw new Error(\"Perhaps the popup window was blocked\");\n      }\n    } catch (e) {\n      error = e;\n    }\n\n    if (!targetWindow) {\n      _debug(\"Cannot open window. Failing back to '_self'. %s\", error);\n\n      return self;\n    } else {\n      return targetWindow;\n    }\n  } // Frame or window by name\n\n\n  const winOrFrame = frames[target];\n\n  if (winOrFrame) {\n    return winOrFrame;\n  }\n\n  _debug(\"Unknown target '%s'. Failing back to '_self'.\", target);\n\n  return self;\n}\n\nexports.getTargetWindow = getTargetWindow;\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nexports.assert = assert;\n\nfunction assertJsonPatch(patch) {\n  assert(Array.isArray(patch), \"The JSON patch must be an array\");\n  assert(patch.length > 0, \"The JSON patch array should not be empty\");\n  patch.forEach(operation => {\n    assert([\"add\", \"replace\", \"test\", \"move\", \"copy\", \"remove\"].indexOf(operation.op) > -1, 'Each patch operation must have an \"op\" property which must be one of: \"add\", \"replace\", \"test\", \"move\", \"copy\", \"remove\"');\n    assert(operation.path && typeof operation.path, `Invalid \"${operation.op}\" operation. Missing \"path\" property`);\n\n    if (operation.op == \"add\" || operation.op == \"replace\" || operation.op == \"test\") {\n      assert(\"value\" in operation, `Invalid \"${operation.op}\" operation. Missing \"value\" property`);\n      assert(Object.keys(operation).length == 3, `Invalid \"${operation.op}\" operation. Contains unknown properties`);\n    } else if (operation.op == \"move\" || operation.op == \"copy\") {\n      assert(typeof operation.from == \"string\", `Invalid \"${operation.op}\" operation. Requires a string \"from\" property`);\n      assert(Object.keys(operation).length == 3, `Invalid \"${operation.op}\" operation. Contains unknown properties`);\n    } else {\n      assert(Object.keys(operation).length == 2, `Invalid \"${operation.op}\" operation. Contains unknown properties`);\n    }\n  });\n}\n\nexports.assertJsonPatch = assertJsonPatch;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.init = exports.ready = exports.buildTokenRequest = exports.completeAuth = exports.onMessage = exports.isInPopUp = exports.isInFrame = exports.authorize = exports.getSecurityExtensions = exports.fetchWellKnownJson = exports.KEY = void 0;\n/* global window */\n\nconst lib_1 = require(\"./lib\");\nconst Client_1 = require(\"./Client\");\nconst settings_1 = require(\"./settings\");\nObject.defineProperty(exports, \"KEY\", {\n  enumerable: true,\n  get: function () {\n    return settings_1.SMART_KEY;\n  }\n});\nconst debug = lib_1.debug.extend(\"oauth2\");\nfunction isBrowser() {\n  return typeof window === \"object\";\n}\n/**\n * Fetches the well-known json file from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n */\n\nfunction fetchWellKnownJson() {\n  let baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n  let requestOptions = arguments.length > 1 ? arguments[1] : undefined;\n  const url = String(baseUrl).replace(/\\/*$/, \"/\") + \".well-known/smart-configuration\";\n  return lib_1.getAndCache(url, requestOptions).catch(ex => {\n    throw new Error(`Failed to fetch the well-known json \"${url}\". ${ex.message}`);\n  });\n}\nexports.fetchWellKnownJson = fetchWellKnownJson;\n/**\n * Fetch a \"WellKnownJson\" and extract the SMART endpoints from it\n */\n\nfunction getSecurityExtensionsFromWellKnownJson() {\n  let baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n  let requestOptions = arguments.length > 1 ? arguments[1] : undefined;\n  return fetchWellKnownJson(baseUrl, requestOptions).then(meta => {\n    if (!meta.authorization_endpoint || !meta.token_endpoint) {\n      throw new Error(\"Invalid wellKnownJson\");\n    }\n    return {\n      registrationUri: meta.registration_endpoint || \"\",\n      authorizeUri: meta.authorization_endpoint,\n      tokenUri: meta.token_endpoint\n    };\n  });\n}\n/**\n * Fetch a `CapabilityStatement` and extract the SMART endpoints from it\n */\n\nfunction getSecurityExtensionsFromConformanceStatement() {\n  let baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n  let requestOptions = arguments.length > 1 ? arguments[1] : undefined;\n  return lib_1.fetchConformanceStatement(baseUrl, requestOptions).then(meta => {\n    const nsUri = \"http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris\";\n    const extensions = (lib_1.getPath(meta || {}, \"rest.0.security.extension\") || []).filter(e => e.url === nsUri).map(o => o.extension)[0];\n    const out = {\n      registrationUri: \"\",\n      authorizeUri: \"\",\n      tokenUri: \"\"\n    };\n    if (extensions) {\n      extensions.forEach(ext => {\n        if (ext.url === \"register\") {\n          out.registrationUri = ext.valueUri;\n        }\n        if (ext.url === \"authorize\") {\n          out.authorizeUri = ext.valueUri;\n        }\n        if (ext.url === \"token\") {\n          out.tokenUri = ext.valueUri;\n        }\n      });\n    }\n    return out;\n  });\n}\n/**\n * This works similarly to `Promise.any()`. The tasks are objects containing a\n * request promise and it's AbortController. Returns a promise that will be\n * resolved with the return value of the first successful request, or rejected\n * with an aggregate error if all tasks fail. Any requests, other than the first\n * one that succeeds will be aborted.\n */\n\nfunction any(tasks) {\n  const len = tasks.length;\n  const errors = [];\n  let resolved = false;\n  return new Promise((resolve, reject) => {\n    function onSuccess(task, result) {\n      task.complete = true;\n      if (!resolved) {\n        resolved = true;\n        tasks.forEach(t => {\n          if (!t.complete) {\n            t.controller.abort();\n          }\n        });\n        resolve(result);\n      }\n    }\n    function onError(error) {\n      if (errors.push(error) === len) {\n        reject(new Error(errors.map(e => e.message).join(\"; \")));\n      }\n    }\n    tasks.forEach(t => {\n      t.promise.then(result => onSuccess(t, result), onError);\n    });\n  });\n}\n/**\n * Given a FHIR server, returns an object with it's Oauth security endpoints\n * that we are interested in. This will try to find the info in both the\n * `CapabilityStatement` and the `.well-known/smart-configuration`. Whatever\n * Arrives first will be used and the other request will be aborted.\n * @param [baseUrl] Fhir server base URL\n * @param [env] The Adapter\n */\n\nfunction getSecurityExtensions(env) {\n  let baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"/\";\n  const AbortController = env.getAbortController();\n  const abortController1 = new AbortController();\n  const abortController2 = new AbortController();\n  return any([{\n    controller: abortController1,\n    promise: getSecurityExtensionsFromWellKnownJson(baseUrl, {\n      signal: abortController1.signal\n    })\n  }, {\n    controller: abortController2,\n    promise: getSecurityExtensionsFromConformanceStatement(baseUrl, {\n      signal: abortController2.signal\n    })\n  }]);\n}\nexports.getSecurityExtensions = getSecurityExtensions;\n/**\n * Starts the SMART Launch Sequence.\n * > **IMPORTANT**:\n *   `authorize()` will end up redirecting you to the authorization server.\n *    This means that you should not add anything to the returned promise chain.\n *    Any code written directly after the authorize() call might not be executed\n *    due to that redirect!\n * @param env\n * @param [params]\n */\n\nasync function authorize(env) {\n  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const url = env.getUrl(); // Multiple config for EHR launches ---------------------------------------\n\n  if (Array.isArray(params)) {\n    const urlISS = url.searchParams.get(\"iss\") || url.searchParams.get(\"fhirServiceUrl\");\n    if (!urlISS) {\n      throw new Error('Passing in an \"iss\" url parameter is required if authorize ' + 'uses multiple configurations');\n    } // pick the right config\n\n    const cfg = params.find(x => {\n      if (x.issMatch) {\n        if (typeof x.issMatch === \"function\") {\n          return !!x.issMatch(urlISS);\n        }\n        if (typeof x.issMatch === \"string\") {\n          return x.issMatch === urlISS;\n        }\n        if (x.issMatch instanceof RegExp) {\n          return x.issMatch.test(urlISS);\n        }\n      }\n      return false;\n    });\n    lib_1.assert(cfg, `No configuration found matching the current \"iss\" parameter \"${urlISS}\"`);\n    return await authorize(env, cfg);\n  } // ------------------------------------------------------------------------\n  // Obtain input\n\n  const {\n    redirect_uri,\n    clientSecret,\n    fakeTokenResponse,\n    patientId,\n    encounterId,\n    client_id,\n    target,\n    width,\n    height\n  } = params;\n  let {\n    iss,\n    launch,\n    fhirServiceUrl,\n    redirectUri,\n    noRedirect,\n    scope = \"\",\n    clientId,\n    completeInTarget\n  } = params;\n  const storage = env.getStorage(); // For these three an url param takes precedence over inline option\n\n  iss = url.searchParams.get(\"iss\") || iss;\n  fhirServiceUrl = url.searchParams.get(\"fhirServiceUrl\") || fhirServiceUrl;\n  launch = url.searchParams.get(\"launch\") || launch;\n  if (!clientId) {\n    clientId = client_id;\n  }\n  if (!redirectUri) {\n    redirectUri = redirect_uri;\n  }\n  if (!redirectUri) {\n    redirectUri = env.relative(\".\");\n  } else if (!redirectUri.match(/^https?\\:\\/\\//)) {\n    redirectUri = env.relative(redirectUri);\n  }\n  const serverUrl = String(iss || fhirServiceUrl || \"\"); // Validate input\n\n  if (!serverUrl) {\n    throw new Error(\"No server url found. It must be specified as `iss` or as \" + \"`fhirServiceUrl` parameter\");\n  }\n  if (iss) {\n    debug(\"Making %s launch...\", launch ? \"EHR\" : \"standalone\");\n  } // append launch scope if needed\n\n  if (launch && !scope.match(/launch/)) {\n    scope += \" launch\";\n  }\n  if (isBrowser()) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp();\n    if ((inFrame || inPopUp) && completeInTarget !== true && completeInTarget !== false) {\n      // completeInTarget will default to true if authorize is called from\n      // within an iframe. This is to avoid issues when the entire app\n      // happens to be rendered in an iframe (including in some EHRs),\n      // even though that was not how the app developer's intention.\n      completeInTarget = inFrame; // In this case we can't always make the best decision so ask devs\n      // to be explicit in their configuration.\n\n      console.warn('Your app is being authorized from within an iframe or popup ' + 'window. Please be explicit and provide a \"completeInTarget\" ' + 'option. Use \"true\" to complete the authorization in the ' + 'same window, or \"false\" to try to complete it in the parent ' + 'or the opener window. See http://docs.smarthealthit.org/client-js/api.html');\n    }\n  } // If `authorize` is called, make sure we clear any previous state (in case\n  // this is a re-authorize)\n\n  const oldKey = await storage.get(settings_1.SMART_KEY);\n  await storage.unset(oldKey); // create initial state\n\n  const stateKey = lib_1.randomString(16);\n  const state = {\n    clientId,\n    scope,\n    redirectUri,\n    serverUrl,\n    clientSecret,\n    tokenResponse: {},\n    key: stateKey,\n    completeInTarget\n  };\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true;\n  if (fullSessionStorageSupport) {\n    await storage.set(settings_1.SMART_KEY, stateKey);\n  } // fakeTokenResponse to override stuff (useful in development)\n\n  if (fakeTokenResponse) {\n    Object.assign(state.tokenResponse, fakeTokenResponse);\n  } // Fixed patientId (useful in development)\n\n  if (patientId) {\n    Object.assign(state.tokenResponse, {\n      patient: patientId\n    });\n  } // Fixed encounterId (useful in development)\n\n  if (encounterId) {\n    Object.assign(state.tokenResponse, {\n      encounter: encounterId\n    });\n  }\n  let redirectUrl = redirectUri + \"?state=\" + encodeURIComponent(stateKey); // bypass oauth if fhirServiceUrl is used (but iss takes precedence)\n\n  if (fhirServiceUrl && !iss) {\n    debug(\"Making fake launch...\");\n    await storage.set(stateKey, state);\n    if (noRedirect) {\n      return redirectUrl;\n    }\n    return await env.redirect(redirectUrl);\n  } // Get oauth endpoints and add them to the state\n\n  const extensions = await getSecurityExtensions(env, serverUrl);\n  Object.assign(state, extensions);\n  await storage.set(stateKey, state); // If this happens to be an open server and there is no authorizeUri\n\n  if (!state.authorizeUri) {\n    if (noRedirect) {\n      return redirectUrl;\n    }\n    return await env.redirect(redirectUrl);\n  } // build the redirect uri\n\n  const redirectParams = [\"response_type=code\", \"client_id=\" + encodeURIComponent(clientId || \"\"), \"scope=\" + encodeURIComponent(scope), \"redirect_uri=\" + encodeURIComponent(redirectUri), \"aud=\" + encodeURIComponent(serverUrl), \"state=\" + encodeURIComponent(stateKey)]; // also pass this in case of EHR launch\n\n  if (launch) {\n    redirectParams.push(\"launch=\" + encodeURIComponent(launch));\n  }\n  redirectUrl = state.authorizeUri + \"?\" + redirectParams.join(\"&\");\n  if (noRedirect) {\n    return redirectUrl;\n  }\n  if (target && isBrowser()) {\n    let win;\n    win = await lib_1.getTargetWindow(target, width, height);\n    if (win !== self) {\n      try {\n        // Also remove any old state from the target window and then\n        // transfer the current state there\n        win.sessionStorage.removeItem(oldKey);\n        win.sessionStorage.setItem(stateKey, JSON.stringify(state));\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.sessionStorage. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        win = self;\n      }\n    }\n    if (win !== self) {\n      try {\n        win.location.href = redirectUrl;\n        self.addEventListener(\"message\", onMessage);\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.location. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        self.location.href = redirectUrl;\n      }\n    } else {\n      self.location.href = redirectUrl;\n    }\n    return;\n  } else {\n    return await env.redirect(redirectUrl);\n  }\n}\nexports.authorize = authorize;\n/**\n * Checks if called within a frame. Only works in browsers!\n * If the current window has a `parent` or `top` properties that refer to\n * another window, returns true. If trying to access `top` or `parent` throws an\n * error, returns true. Otherwise returns `false`.\n */\n\nfunction isInFrame() {\n  try {\n    return self !== top && parent !== self;\n  } catch (e) {\n    return true;\n  }\n}\nexports.isInFrame = isInFrame;\n/**\n * Checks if called within another window (popup or tab). Only works in browsers!\n * To consider itself called in a new window, this function verifies that:\n * 1. `self === top` (not in frame)\n * 2. `!!opener && opener !== self` The window has an opener\n * 3. `!!window.name` The window has a `name` set\n */\n\nfunction isInPopUp() {\n  try {\n    return self === top && !!opener && opener !== self && !!window.name;\n  } catch (e) {\n    return false;\n  }\n}\nexports.isInPopUp = isInPopUp;\n/**\n * Another window can send a \"completeAuth\" message to this one, making it to\n * navigate to e.data.url\n * @param e The message event\n */\n\nfunction onMessage(e) {\n  if (e.data.type == \"completeAuth\" && e.origin === new URL(self.location.href).origin) {\n    window.removeEventListener(\"message\", onMessage);\n    window.location.href = e.data.url;\n  }\n}\nexports.onMessage = onMessage;\n/**\n * The completeAuth function should only be called on the page that represents\n * the redirectUri. We typically land there after a redirect from the\n * authorization server..\n */\n\nasync function completeAuth(env) {\n  var _a, _b;\n  const url = env.getUrl();\n  const Storage = env.getStorage();\n  const params = url.searchParams;\n  let key = params.get(\"state\");\n  const code = params.get(\"code\");\n  const authError = params.get(\"error\");\n  const authErrorDescription = params.get(\"error_description\");\n  if (!key) {\n    key = await Storage.get(settings_1.SMART_KEY);\n  } // Start by checking the url for `error` and `error_description` parameters.\n  // This happens when the auth server rejects our authorization attempt. In\n  // this case it has no other way to tell us what the error was, other than\n  // appending these parameters to the redirect url.\n  // From client's point of view, this is not very reliable (because we can't\n  // know how we have landed on this page - was it a redirect or was it loaded\n  // manually). However, if `completeAuth()` is being called, we can assume\n  // that the url comes from the auth server (otherwise the app won't work\n  // anyway).\n\n  if (authError || authErrorDescription) {\n    throw new Error([authError, authErrorDescription].filter(Boolean).join(\": \"));\n  }\n  debug(\"key: %s, code: %s\", key, code); // key might be coming from the page url so it might be empty or missing\n\n  lib_1.assert(key, \"No 'state' parameter found. Please (re)launch the app.\"); // Check if we have a previous state\n\n  let state = await Storage.get(key);\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true; // If we are in a popup window or an iframe and the authorization is\n  // complete, send the location back to our opener and exit.\n\n  if (isBrowser() && state && !state.completeInTarget) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp(); // we are about to return to the opener/parent where completeAuth will\n    // be called again. In rare cases the opener or parent might also be\n    // a frame or popup. Then inFrame or inPopUp will be true but we still\n    // have to stop going up the chain. To guard against that weird form of\n    // recursion we pass one additional parameter to the url which we later\n    // remove.\n\n    if ((inFrame || inPopUp) && !url.searchParams.get(\"complete\")) {\n      url.searchParams.set(\"complete\", \"1\");\n      const {\n        href,\n        origin\n      } = url;\n      if (inFrame) {\n        parent.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n      }\n      if (inPopUp) {\n        opener.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n        window.close();\n      }\n      return new Promise(() => {});\n    }\n  }\n  url.searchParams.delete(\"complete\"); // Do we have to remove the `code` and `state` params from the URL?\n\n  const hasState = params.has(\"state\");\n  if (isBrowser() && lib_1.getPath(env, \"options.replaceBrowserHistory\") && (code || hasState)) {\n    // `code` is the flag that tell us to request an access token.\n    // We have to remove it, otherwise the page will authorize on\n    // every load!\n    if (code) {\n      params.delete(\"code\");\n      debug(\"Removed code parameter from the url.\");\n    } // If we have `fullSessionStorageSupport` it means we no longer\n    // need the `state` key. It will be stored to a well know\n    // location - sessionStorage[SMART_KEY]. However, no\n    // fullSessionStorageSupport means that this \"well know location\"\n    // might be shared between windows and tabs. In this case we\n    // MUST keep the `state` url parameter.\n\n    if (hasState && fullSessionStorageSupport) {\n      params.delete(\"state\");\n      debug(\"Removed state parameter from the url.\");\n    } // If the browser does not support the replaceState method for the\n    // History Web API, the \"code\" parameter cannot be removed. As a\n    // consequence, the page will (re)authorize on every load. The\n    // workaround is to reload the page to new location without those\n    // parameters. If that is not acceptable replaceBrowserHistory\n    // should be set to false.\n\n    if (window.history.replaceState) {\n      window.history.replaceState({}, \"\", url.href);\n    }\n  } // If the state does not exist, it means the page has been loaded directly.\n\n  lib_1.assert(state, \"No state found! Please (re)launch the app.\"); // Assume the client has already completed a token exchange when\n  // there is no code (but we have a state) or access token is found in state\n\n  const authorized = !code || ((_a = state.tokenResponse) === null || _a === void 0 ? void 0 : _a.access_token); // If we are authorized already, then this is just a reload.\n  // Otherwise, we have to complete the code flow\n\n  if (!authorized && state.tokenUri) {\n    lib_1.assert(code, \"'code' url parameter is required\");\n    debug(\"Preparing to exchange the code for access token...\");\n    const requestOptions = buildTokenRequest(env, code, state);\n    debug(\"Token request options: %O\", requestOptions); // The EHR authorization server SHALL return a JSON structure that\n    // includes an access token or a message indicating that the\n    // authorization request has been denied.\n\n    const tokenResponse = await lib_1.request(state.tokenUri, requestOptions);\n    debug(\"Token response: %O\", tokenResponse);\n    lib_1.assert(tokenResponse.access_token, \"Failed to obtain access token.\"); // Now we need to determine when is this authorization going to expire\n\n    state.expiresAt = lib_1.getAccessTokenExpiration(tokenResponse, env); // save the tokenResponse so that we don't have to re-authorize on\n    // every page reload\n\n    state = Object.assign(Object.assign({}, state), {\n      tokenResponse\n    });\n    await Storage.set(key, state);\n    debug(\"Authorization successful!\");\n  } else {\n    debug(((_b = state.tokenResponse) === null || _b === void 0 ? void 0 : _b.access_token) ? \"Already authorized\" : \"No authorization needed\");\n  }\n  if (fullSessionStorageSupport) {\n    await Storage.set(settings_1.SMART_KEY, key);\n  }\n  const client = new Client_1.default(env, state);\n  debug(\"Created client instance: %O\", client);\n  return client;\n}\nexports.completeAuth = completeAuth;\n/**\n * Builds the token request options. Does not make the request, just\n * creates it's configuration and returns it in a Promise.\n */\n\nfunction buildTokenRequest(env, code, state) {\n  const {\n    redirectUri,\n    clientSecret,\n    tokenUri,\n    clientId\n  } = state;\n  lib_1.assert(redirectUri, \"Missing state.redirectUri\");\n  lib_1.assert(tokenUri, \"Missing state.tokenUri\");\n  lib_1.assert(clientId, \"Missing state.clientId\");\n  const requestOptions = {\n    method: \"POST\",\n    headers: {\n      \"content-type\": \"application/x-www-form-urlencoded\"\n    },\n    body: `code=${code}&grant_type=authorization_code&redirect_uri=${encodeURIComponent(redirectUri)}`\n  }; // For public apps, authentication is not possible (and thus not required),\n  // since a client with no secret cannot prove its identity when it issues a\n  // call. (The end-to-end system can still be secure because the client comes\n  // from a known, https protected endpoint specified and enforced by the\n  // redirect uri.) For confidential apps, an Authorization header using HTTP\n  // Basic authentication is required, where the username is the app’s\n  // client_id and the password is the app’s client_secret (see example).\n\n  if (clientSecret) {\n    requestOptions.headers.Authorization = \"Basic \" + env.btoa(clientId + \":\" + clientSecret);\n    debug(\"Using state.clientSecret to construct the authorization header: %s\", requestOptions.headers.Authorization);\n  } else {\n    debug(\"No clientSecret found in state. Adding the clientId to the POST body\");\n    requestOptions.body += `&client_id=${encodeURIComponent(clientId)}`;\n  }\n  return requestOptions;\n}\nexports.buildTokenRequest = buildTokenRequest;\n/**\n * @param env\n * @param [onSuccess]\n * @param [onError]\n */\n\nasync function ready(env, onSuccess, onError) {\n  let task = completeAuth(env);\n  if (onSuccess) {\n    task = task.then(onSuccess);\n  }\n  if (onError) {\n    task = task.catch(onError);\n  }\n  return task;\n}\nexports.ready = ready;\n/**\n * This function can be used when you want to handle everything in one page\n * (no launch endpoint needed). You can think of it as if it does:\n * ```js\n * authorize(options).then(ready)\n * ```\n *\n * **Be careful with init()!** There are some details you need to be aware of:\n *\n * 1. It will only work if your launch_uri is the same as your redirect_uri.\n *    While this should be valid, we can’t promise that every EHR will allow you\n *    to register client with such settings.\n * 2. Internally, `init()` will be called twice. First it will redirect to the\n *    EHR, then the EHR will redirect back to the page where init() will be\n *    called again to complete the authorization. This is generally fine,\n *    because the returned promise will only be resolved once, after the second\n *    execution, but please also consider the following:\n *    - You should wrap all your app’s code in a function that is only executed\n *      after `init()` resolves!\n *    - Since the page will be loaded twice, you must be careful if your code\n *      has global side effects that can persist between page reloads\n *      (for example writing to localStorage).\n * 3. For standalone launch, only use init in combination with offline_access\n *    scope. Once the access_token expires, if you don’t have a refresh_token\n *    there is no way to re-authorize properly. We detect that and delete the\n *    expired access token, but it still means that the user will have to\n *    refresh the page twice to re-authorize.\n * @param env The adapter\n * @param options The authorize options\n */\n\nasync function init(env, options) {\n  const url = env.getUrl();\n  const code = url.searchParams.get(\"code\");\n  const state = url.searchParams.get(\"state\"); // if `code` and `state` params are present we need to complete the auth flow\n\n  if (code && state) {\n    return completeAuth(env);\n  } // Check for existing client state. If state is found, it means a client\n  // instance have already been created in this session and we should try to\n  // \"revive\" it.\n\n  const storage = env.getStorage();\n  const key = state || (await storage.get(settings_1.SMART_KEY));\n  const cached = await storage.get(key);\n  if (cached) {\n    return new Client_1.default(env, cached);\n  } // Otherwise try to launch\n\n  return authorize(env, options).then(() => {\n    // `init` promises a Client but that cannot happen in this case. The\n    // browser will be redirected (unload the page and be redirected back\n    // to it later and the same init function will be called again). On\n    // success, authorize will resolve with the redirect url but we don't\n    // want to return that from this promise chain because it is not a\n    // Client instance. At the same time, if authorize fails, we do want to\n    // pass the error to those waiting for a client instance.\n    return new Promise(() => {});\n  });\n}\nexports.init = init;","map":{"version":3,"names":["Object","defineProperty","exports","value","init","ready","buildTokenRequest","completeAuth","onMessage","isInPopUp","isInFrame","authorize","getSecurityExtensions","fetchWellKnownJson","KEY","lib_1","require","Client_1","settings_1","enumerable","get","SMART_KEY","debug","extend","isBrowser","window","baseUrl","requestOptions","url","String","replace","getAndCache","catch","ex","Error","message","getSecurityExtensionsFromWellKnownJson","then","meta","authorization_endpoint","token_endpoint","registrationUri","registration_endpoint","authorizeUri","tokenUri","getSecurityExtensionsFromConformanceStatement","fetchConformanceStatement","nsUri","extensions","getPath","filter","e","map","o","extension","out","forEach","ext","valueUri","any","tasks","len","length","errors","resolved","Promise","resolve","reject","onSuccess","task","result","complete","t","controller","abort","onError","error","push","join","promise","env","AbortController","getAbortController","abortController1","abortController2","signal","params","getUrl","Array","isArray","urlISS","searchParams","cfg","find","x","issMatch","RegExp","test","assert","redirect_uri","clientSecret","fakeTokenResponse","patientId","encounterId","client_id","target","width","height","iss","launch","fhirServiceUrl","redirectUri","noRedirect","scope","clientId","completeInTarget","storage","getStorage","relative","match","serverUrl","inFrame","inPopUp","console","warn","oldKey","unset","stateKey","randomString","state","tokenResponse","key","fullSessionStorageSupport","set","assign","patient","encounter","redirectUrl","encodeURIComponent","redirect","redirectParams","win","getTargetWindow","self","sessionStorage","removeItem","setItem","JSON","stringify","location","href","addEventListener","top","parent","opener","name","data","type","origin","URL","removeEventListener","_a","_b","Storage","code","authError","authErrorDescription","Boolean","postMessage","close","delete","hasState","has","history","replaceState","authorized","access_token","request","expiresAt","getAccessTokenExpiration","client","default","method","headers","body","Authorization","btoa","options","cached"],"sources":["/Users/shivamrustogi/Documents/GitHub/lab4/node_modules/fhirclient/lib/smart.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.init = exports.ready = exports.buildTokenRequest = exports.completeAuth = exports.onMessage = exports.isInPopUp = exports.isInFrame = exports.authorize = exports.getSecurityExtensions = exports.fetchWellKnownJson = exports.KEY = void 0;\n/* global window */\n\nconst lib_1 = require(\"./lib\");\n\nconst Client_1 = require(\"./Client\");\n\nconst settings_1 = require(\"./settings\");\n\nObject.defineProperty(exports, \"KEY\", {\n  enumerable: true,\n  get: function () {\n    return settings_1.SMART_KEY;\n  }\n});\nconst debug = lib_1.debug.extend(\"oauth2\");\n\nfunction isBrowser() {\n  return typeof window === \"object\";\n}\n/**\n * Fetches the well-known json file from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n */\n\n\nfunction fetchWellKnownJson(baseUrl = \"/\", requestOptions) {\n  const url = String(baseUrl).replace(/\\/*$/, \"/\") + \".well-known/smart-configuration\";\n  return lib_1.getAndCache(url, requestOptions).catch(ex => {\n    throw new Error(`Failed to fetch the well-known json \"${url}\". ${ex.message}`);\n  });\n}\n\nexports.fetchWellKnownJson = fetchWellKnownJson;\n/**\n * Fetch a \"WellKnownJson\" and extract the SMART endpoints from it\n */\n\nfunction getSecurityExtensionsFromWellKnownJson(baseUrl = \"/\", requestOptions) {\n  return fetchWellKnownJson(baseUrl, requestOptions).then(meta => {\n    if (!meta.authorization_endpoint || !meta.token_endpoint) {\n      throw new Error(\"Invalid wellKnownJson\");\n    }\n\n    return {\n      registrationUri: meta.registration_endpoint || \"\",\n      authorizeUri: meta.authorization_endpoint,\n      tokenUri: meta.token_endpoint\n    };\n  });\n}\n/**\n * Fetch a `CapabilityStatement` and extract the SMART endpoints from it\n */\n\n\nfunction getSecurityExtensionsFromConformanceStatement(baseUrl = \"/\", requestOptions) {\n  return lib_1.fetchConformanceStatement(baseUrl, requestOptions).then(meta => {\n    const nsUri = \"http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris\";\n    const extensions = (lib_1.getPath(meta || {}, \"rest.0.security.extension\") || []).filter(e => e.url === nsUri).map(o => o.extension)[0];\n    const out = {\n      registrationUri: \"\",\n      authorizeUri: \"\",\n      tokenUri: \"\"\n    };\n\n    if (extensions) {\n      extensions.forEach(ext => {\n        if (ext.url === \"register\") {\n          out.registrationUri = ext.valueUri;\n        }\n\n        if (ext.url === \"authorize\") {\n          out.authorizeUri = ext.valueUri;\n        }\n\n        if (ext.url === \"token\") {\n          out.tokenUri = ext.valueUri;\n        }\n      });\n    }\n\n    return out;\n  });\n}\n/**\n * This works similarly to `Promise.any()`. The tasks are objects containing a\n * request promise and it's AbortController. Returns a promise that will be\n * resolved with the return value of the first successful request, or rejected\n * with an aggregate error if all tasks fail. Any requests, other than the first\n * one that succeeds will be aborted.\n */\n\n\nfunction any(tasks) {\n  const len = tasks.length;\n  const errors = [];\n  let resolved = false;\n  return new Promise((resolve, reject) => {\n    function onSuccess(task, result) {\n      task.complete = true;\n\n      if (!resolved) {\n        resolved = true;\n        tasks.forEach(t => {\n          if (!t.complete) {\n            t.controller.abort();\n          }\n        });\n        resolve(result);\n      }\n    }\n\n    function onError(error) {\n      if (errors.push(error) === len) {\n        reject(new Error(errors.map(e => e.message).join(\"; \")));\n      }\n    }\n\n    tasks.forEach(t => {\n      t.promise.then(result => onSuccess(t, result), onError);\n    });\n  });\n}\n/**\n * Given a FHIR server, returns an object with it's Oauth security endpoints\n * that we are interested in. This will try to find the info in both the\n * `CapabilityStatement` and the `.well-known/smart-configuration`. Whatever\n * Arrives first will be used and the other request will be aborted.\n * @param [baseUrl] Fhir server base URL\n * @param [env] The Adapter\n */\n\n\nfunction getSecurityExtensions(env, baseUrl = \"/\") {\n  const AbortController = env.getAbortController();\n  const abortController1 = new AbortController();\n  const abortController2 = new AbortController();\n  return any([{\n    controller: abortController1,\n    promise: getSecurityExtensionsFromWellKnownJson(baseUrl, {\n      signal: abortController1.signal\n    })\n  }, {\n    controller: abortController2,\n    promise: getSecurityExtensionsFromConformanceStatement(baseUrl, {\n      signal: abortController2.signal\n    })\n  }]);\n}\n\nexports.getSecurityExtensions = getSecurityExtensions;\n/**\n * Starts the SMART Launch Sequence.\n * > **IMPORTANT**:\n *   `authorize()` will end up redirecting you to the authorization server.\n *    This means that you should not add anything to the returned promise chain.\n *    Any code written directly after the authorize() call might not be executed\n *    due to that redirect!\n * @param env\n * @param [params]\n */\n\nasync function authorize(env, params = {}) {\n  const url = env.getUrl(); // Multiple config for EHR launches ---------------------------------------\n\n  if (Array.isArray(params)) {\n    const urlISS = url.searchParams.get(\"iss\") || url.searchParams.get(\"fhirServiceUrl\");\n\n    if (!urlISS) {\n      throw new Error('Passing in an \"iss\" url parameter is required if authorize ' + 'uses multiple configurations');\n    } // pick the right config\n\n\n    const cfg = params.find(x => {\n      if (x.issMatch) {\n        if (typeof x.issMatch === \"function\") {\n          return !!x.issMatch(urlISS);\n        }\n\n        if (typeof x.issMatch === \"string\") {\n          return x.issMatch === urlISS;\n        }\n\n        if (x.issMatch instanceof RegExp) {\n          return x.issMatch.test(urlISS);\n        }\n      }\n\n      return false;\n    });\n    lib_1.assert(cfg, `No configuration found matching the current \"iss\" parameter \"${urlISS}\"`);\n    return await authorize(env, cfg);\n  } // ------------------------------------------------------------------------\n  // Obtain input\n\n\n  const {\n    redirect_uri,\n    clientSecret,\n    fakeTokenResponse,\n    patientId,\n    encounterId,\n    client_id,\n    target,\n    width,\n    height\n  } = params;\n  let {\n    iss,\n    launch,\n    fhirServiceUrl,\n    redirectUri,\n    noRedirect,\n    scope = \"\",\n    clientId,\n    completeInTarget\n  } = params;\n  const storage = env.getStorage(); // For these three an url param takes precedence over inline option\n\n  iss = url.searchParams.get(\"iss\") || iss;\n  fhirServiceUrl = url.searchParams.get(\"fhirServiceUrl\") || fhirServiceUrl;\n  launch = url.searchParams.get(\"launch\") || launch;\n\n  if (!clientId) {\n    clientId = client_id;\n  }\n\n  if (!redirectUri) {\n    redirectUri = redirect_uri;\n  }\n\n  if (!redirectUri) {\n    redirectUri = env.relative(\".\");\n  } else if (!redirectUri.match(/^https?\\:\\/\\//)) {\n    redirectUri = env.relative(redirectUri);\n  }\n\n  const serverUrl = String(iss || fhirServiceUrl || \"\"); // Validate input\n\n  if (!serverUrl) {\n    throw new Error(\"No server url found. It must be specified as `iss` or as \" + \"`fhirServiceUrl` parameter\");\n  }\n\n  if (iss) {\n    debug(\"Making %s launch...\", launch ? \"EHR\" : \"standalone\");\n  } // append launch scope if needed\n\n\n  if (launch && !scope.match(/launch/)) {\n    scope += \" launch\";\n  }\n\n  if (isBrowser()) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp();\n\n    if ((inFrame || inPopUp) && completeInTarget !== true && completeInTarget !== false) {\n      // completeInTarget will default to true if authorize is called from\n      // within an iframe. This is to avoid issues when the entire app\n      // happens to be rendered in an iframe (including in some EHRs),\n      // even though that was not how the app developer's intention.\n      completeInTarget = inFrame; // In this case we can't always make the best decision so ask devs\n      // to be explicit in their configuration.\n\n      console.warn('Your app is being authorized from within an iframe or popup ' + 'window. Please be explicit and provide a \"completeInTarget\" ' + 'option. Use \"true\" to complete the authorization in the ' + 'same window, or \"false\" to try to complete it in the parent ' + 'or the opener window. See http://docs.smarthealthit.org/client-js/api.html');\n    }\n  } // If `authorize` is called, make sure we clear any previous state (in case\n  // this is a re-authorize)\n\n\n  const oldKey = await storage.get(settings_1.SMART_KEY);\n  await storage.unset(oldKey); // create initial state\n\n  const stateKey = lib_1.randomString(16);\n  const state = {\n    clientId,\n    scope,\n    redirectUri,\n    serverUrl,\n    clientSecret,\n    tokenResponse: {},\n    key: stateKey,\n    completeInTarget\n  };\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true;\n\n  if (fullSessionStorageSupport) {\n    await storage.set(settings_1.SMART_KEY, stateKey);\n  } // fakeTokenResponse to override stuff (useful in development)\n\n\n  if (fakeTokenResponse) {\n    Object.assign(state.tokenResponse, fakeTokenResponse);\n  } // Fixed patientId (useful in development)\n\n\n  if (patientId) {\n    Object.assign(state.tokenResponse, {\n      patient: patientId\n    });\n  } // Fixed encounterId (useful in development)\n\n\n  if (encounterId) {\n    Object.assign(state.tokenResponse, {\n      encounter: encounterId\n    });\n  }\n\n  let redirectUrl = redirectUri + \"?state=\" + encodeURIComponent(stateKey); // bypass oauth if fhirServiceUrl is used (but iss takes precedence)\n\n  if (fhirServiceUrl && !iss) {\n    debug(\"Making fake launch...\");\n    await storage.set(stateKey, state);\n\n    if (noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // Get oauth endpoints and add them to the state\n\n\n  const extensions = await getSecurityExtensions(env, serverUrl);\n  Object.assign(state, extensions);\n  await storage.set(stateKey, state); // If this happens to be an open server and there is no authorizeUri\n\n  if (!state.authorizeUri) {\n    if (noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // build the redirect uri\n\n\n  const redirectParams = [\"response_type=code\", \"client_id=\" + encodeURIComponent(clientId || \"\"), \"scope=\" + encodeURIComponent(scope), \"redirect_uri=\" + encodeURIComponent(redirectUri), \"aud=\" + encodeURIComponent(serverUrl), \"state=\" + encodeURIComponent(stateKey)]; // also pass this in case of EHR launch\n\n  if (launch) {\n    redirectParams.push(\"launch=\" + encodeURIComponent(launch));\n  }\n\n  redirectUrl = state.authorizeUri + \"?\" + redirectParams.join(\"&\");\n\n  if (noRedirect) {\n    return redirectUrl;\n  }\n\n  if (target && isBrowser()) {\n    let win;\n    win = await lib_1.getTargetWindow(target, width, height);\n\n    if (win !== self) {\n      try {\n        // Also remove any old state from the target window and then\n        // transfer the current state there\n        win.sessionStorage.removeItem(oldKey);\n        win.sessionStorage.setItem(stateKey, JSON.stringify(state));\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.sessionStorage. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        win = self;\n      }\n    }\n\n    if (win !== self) {\n      try {\n        win.location.href = redirectUrl;\n        self.addEventListener(\"message\", onMessage);\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.location. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        self.location.href = redirectUrl;\n      }\n    } else {\n      self.location.href = redirectUrl;\n    }\n\n    return;\n  } else {\n    return await env.redirect(redirectUrl);\n  }\n}\n\nexports.authorize = authorize;\n/**\n * Checks if called within a frame. Only works in browsers!\n * If the current window has a `parent` or `top` properties that refer to\n * another window, returns true. If trying to access `top` or `parent` throws an\n * error, returns true. Otherwise returns `false`.\n */\n\nfunction isInFrame() {\n  try {\n    return self !== top && parent !== self;\n  } catch (e) {\n    return true;\n  }\n}\n\nexports.isInFrame = isInFrame;\n/**\n * Checks if called within another window (popup or tab). Only works in browsers!\n * To consider itself called in a new window, this function verifies that:\n * 1. `self === top` (not in frame)\n * 2. `!!opener && opener !== self` The window has an opener\n * 3. `!!window.name` The window has a `name` set\n */\n\nfunction isInPopUp() {\n  try {\n    return self === top && !!opener && opener !== self && !!window.name;\n  } catch (e) {\n    return false;\n  }\n}\n\nexports.isInPopUp = isInPopUp;\n/**\n * Another window can send a \"completeAuth\" message to this one, making it to\n * navigate to e.data.url\n * @param e The message event\n */\n\nfunction onMessage(e) {\n  if (e.data.type == \"completeAuth\" && e.origin === new URL(self.location.href).origin) {\n    window.removeEventListener(\"message\", onMessage);\n    window.location.href = e.data.url;\n  }\n}\n\nexports.onMessage = onMessage;\n/**\n * The completeAuth function should only be called on the page that represents\n * the redirectUri. We typically land there after a redirect from the\n * authorization server..\n */\n\nasync function completeAuth(env) {\n  var _a, _b;\n\n  const url = env.getUrl();\n  const Storage = env.getStorage();\n  const params = url.searchParams;\n  let key = params.get(\"state\");\n  const code = params.get(\"code\");\n  const authError = params.get(\"error\");\n  const authErrorDescription = params.get(\"error_description\");\n\n  if (!key) {\n    key = await Storage.get(settings_1.SMART_KEY);\n  } // Start by checking the url for `error` and `error_description` parameters.\n  // This happens when the auth server rejects our authorization attempt. In\n  // this case it has no other way to tell us what the error was, other than\n  // appending these parameters to the redirect url.\n  // From client's point of view, this is not very reliable (because we can't\n  // know how we have landed on this page - was it a redirect or was it loaded\n  // manually). However, if `completeAuth()` is being called, we can assume\n  // that the url comes from the auth server (otherwise the app won't work\n  // anyway).\n\n\n  if (authError || authErrorDescription) {\n    throw new Error([authError, authErrorDescription].filter(Boolean).join(\": \"));\n  }\n\n  debug(\"key: %s, code: %s\", key, code); // key might be coming from the page url so it might be empty or missing\n\n  lib_1.assert(key, \"No 'state' parameter found. Please (re)launch the app.\"); // Check if we have a previous state\n\n  let state = await Storage.get(key);\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true; // If we are in a popup window or an iframe and the authorization is\n  // complete, send the location back to our opener and exit.\n\n  if (isBrowser() && state && !state.completeInTarget) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp(); // we are about to return to the opener/parent where completeAuth will\n    // be called again. In rare cases the opener or parent might also be\n    // a frame or popup. Then inFrame or inPopUp will be true but we still\n    // have to stop going up the chain. To guard against that weird form of\n    // recursion we pass one additional parameter to the url which we later\n    // remove.\n\n    if ((inFrame || inPopUp) && !url.searchParams.get(\"complete\")) {\n      url.searchParams.set(\"complete\", \"1\");\n      const {\n        href,\n        origin\n      } = url;\n\n      if (inFrame) {\n        parent.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n      }\n\n      if (inPopUp) {\n        opener.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n        window.close();\n      }\n\n      return new Promise(() => {});\n    }\n  }\n\n  url.searchParams.delete(\"complete\"); // Do we have to remove the `code` and `state` params from the URL?\n\n  const hasState = params.has(\"state\");\n\n  if (isBrowser() && lib_1.getPath(env, \"options.replaceBrowserHistory\") && (code || hasState)) {\n    // `code` is the flag that tell us to request an access token.\n    // We have to remove it, otherwise the page will authorize on\n    // every load!\n    if (code) {\n      params.delete(\"code\");\n      debug(\"Removed code parameter from the url.\");\n    } // If we have `fullSessionStorageSupport` it means we no longer\n    // need the `state` key. It will be stored to a well know\n    // location - sessionStorage[SMART_KEY]. However, no\n    // fullSessionStorageSupport means that this \"well know location\"\n    // might be shared between windows and tabs. In this case we\n    // MUST keep the `state` url parameter.\n\n\n    if (hasState && fullSessionStorageSupport) {\n      params.delete(\"state\");\n      debug(\"Removed state parameter from the url.\");\n    } // If the browser does not support the replaceState method for the\n    // History Web API, the \"code\" parameter cannot be removed. As a\n    // consequence, the page will (re)authorize on every load. The\n    // workaround is to reload the page to new location without those\n    // parameters. If that is not acceptable replaceBrowserHistory\n    // should be set to false.\n\n\n    if (window.history.replaceState) {\n      window.history.replaceState({}, \"\", url.href);\n    }\n  } // If the state does not exist, it means the page has been loaded directly.\n\n\n  lib_1.assert(state, \"No state found! Please (re)launch the app.\"); // Assume the client has already completed a token exchange when\n  // there is no code (but we have a state) or access token is found in state\n\n  const authorized = !code || ((_a = state.tokenResponse) === null || _a === void 0 ? void 0 : _a.access_token); // If we are authorized already, then this is just a reload.\n  // Otherwise, we have to complete the code flow\n\n  if (!authorized && state.tokenUri) {\n    lib_1.assert(code, \"'code' url parameter is required\");\n    debug(\"Preparing to exchange the code for access token...\");\n    const requestOptions = buildTokenRequest(env, code, state);\n    debug(\"Token request options: %O\", requestOptions); // The EHR authorization server SHALL return a JSON structure that\n    // includes an access token or a message indicating that the\n    // authorization request has been denied.\n\n    const tokenResponse = await lib_1.request(state.tokenUri, requestOptions);\n    debug(\"Token response: %O\", tokenResponse);\n    lib_1.assert(tokenResponse.access_token, \"Failed to obtain access token.\"); // Now we need to determine when is this authorization going to expire\n\n    state.expiresAt = lib_1.getAccessTokenExpiration(tokenResponse, env); // save the tokenResponse so that we don't have to re-authorize on\n    // every page reload\n\n    state = Object.assign(Object.assign({}, state), {\n      tokenResponse\n    });\n    await Storage.set(key, state);\n    debug(\"Authorization successful!\");\n  } else {\n    debug(((_b = state.tokenResponse) === null || _b === void 0 ? void 0 : _b.access_token) ? \"Already authorized\" : \"No authorization needed\");\n  }\n\n  if (fullSessionStorageSupport) {\n    await Storage.set(settings_1.SMART_KEY, key);\n  }\n\n  const client = new Client_1.default(env, state);\n  debug(\"Created client instance: %O\", client);\n  return client;\n}\n\nexports.completeAuth = completeAuth;\n/**\n * Builds the token request options. Does not make the request, just\n * creates it's configuration and returns it in a Promise.\n */\n\nfunction buildTokenRequest(env, code, state) {\n  const {\n    redirectUri,\n    clientSecret,\n    tokenUri,\n    clientId\n  } = state;\n  lib_1.assert(redirectUri, \"Missing state.redirectUri\");\n  lib_1.assert(tokenUri, \"Missing state.tokenUri\");\n  lib_1.assert(clientId, \"Missing state.clientId\");\n  const requestOptions = {\n    method: \"POST\",\n    headers: {\n      \"content-type\": \"application/x-www-form-urlencoded\"\n    },\n    body: `code=${code}&grant_type=authorization_code&redirect_uri=${encodeURIComponent(redirectUri)}`\n  }; // For public apps, authentication is not possible (and thus not required),\n  // since a client with no secret cannot prove its identity when it issues a\n  // call. (The end-to-end system can still be secure because the client comes\n  // from a known, https protected endpoint specified and enforced by the\n  // redirect uri.) For confidential apps, an Authorization header using HTTP\n  // Basic authentication is required, where the username is the app’s\n  // client_id and the password is the app’s client_secret (see example).\n\n  if (clientSecret) {\n    requestOptions.headers.Authorization = \"Basic \" + env.btoa(clientId + \":\" + clientSecret);\n    debug(\"Using state.clientSecret to construct the authorization header: %s\", requestOptions.headers.Authorization);\n  } else {\n    debug(\"No clientSecret found in state. Adding the clientId to the POST body\");\n    requestOptions.body += `&client_id=${encodeURIComponent(clientId)}`;\n  }\n\n  return requestOptions;\n}\n\nexports.buildTokenRequest = buildTokenRequest;\n/**\n * @param env\n * @param [onSuccess]\n * @param [onError]\n */\n\nasync function ready(env, onSuccess, onError) {\n  let task = completeAuth(env);\n\n  if (onSuccess) {\n    task = task.then(onSuccess);\n  }\n\n  if (onError) {\n    task = task.catch(onError);\n  }\n\n  return task;\n}\n\nexports.ready = ready;\n/**\n * This function can be used when you want to handle everything in one page\n * (no launch endpoint needed). You can think of it as if it does:\n * ```js\n * authorize(options).then(ready)\n * ```\n *\n * **Be careful with init()!** There are some details you need to be aware of:\n *\n * 1. It will only work if your launch_uri is the same as your redirect_uri.\n *    While this should be valid, we can’t promise that every EHR will allow you\n *    to register client with such settings.\n * 2. Internally, `init()` will be called twice. First it will redirect to the\n *    EHR, then the EHR will redirect back to the page where init() will be\n *    called again to complete the authorization. This is generally fine,\n *    because the returned promise will only be resolved once, after the second\n *    execution, but please also consider the following:\n *    - You should wrap all your app’s code in a function that is only executed\n *      after `init()` resolves!\n *    - Since the page will be loaded twice, you must be careful if your code\n *      has global side effects that can persist between page reloads\n *      (for example writing to localStorage).\n * 3. For standalone launch, only use init in combination with offline_access\n *    scope. Once the access_token expires, if you don’t have a refresh_token\n *    there is no way to re-authorize properly. We detect that and delete the\n *    expired access token, but it still means that the user will have to\n *    refresh the page twice to re-authorize.\n * @param env The adapter\n * @param options The authorize options\n */\n\nasync function init(env, options) {\n  const url = env.getUrl();\n  const code = url.searchParams.get(\"code\");\n  const state = url.searchParams.get(\"state\"); // if `code` and `state` params are present we need to complete the auth flow\n\n  if (code && state) {\n    return completeAuth(env);\n  } // Check for existing client state. If state is found, it means a client\n  // instance have already been created in this session and we should try to\n  // \"revive\" it.\n\n\n  const storage = env.getStorage();\n  const key = state || (await storage.get(settings_1.SMART_KEY));\n  const cached = await storage.get(key);\n\n  if (cached) {\n    return new Client_1.default(env, cached);\n  } // Otherwise try to launch\n\n\n  return authorize(env, options).then(() => {\n    // `init` promises a Client but that cannot happen in this case. The\n    // browser will be redirected (unload the page and be redirected back\n    // to it later and the same init function will be called again). On\n    // success, authorize will resolve with the redirect url but we don't\n    // want to return that from this promise chain because it is not a\n    // Client instance. At the same time, if authorize fails, we do want to\n    // pass the error to those waiting for a client instance.\n    return new Promise(() => {});\n  });\n}\n\nexports.init = init;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
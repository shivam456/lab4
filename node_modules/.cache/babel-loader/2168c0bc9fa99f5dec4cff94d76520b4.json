{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.init = exports.ready = exports.buildTokenRequest = exports.completeAuth = exports.onMessage = exports.isInPopUp = exports.isInFrame = exports.authorize = exports.getSecurityExtensions = exports.fetchWellKnownJson = exports.KEY = void 0;\n/* global window */\n\nconst lib_1 = require(\"./lib\");\n\nconst Client_1 = require(\"./Client\");\n\nconst settings_1 = require(\"./settings\");\n\nObject.defineProperty(exports, \"KEY\", {\n  enumerable: true,\n  get: function () {\n    return settings_1.SMART_KEY;\n  }\n});\nconst debug = lib_1.debug.extend(\"oauth2\");\n\nfunction isBrowser() {\n  return typeof window === \"object\";\n}\n/**\n * Fetches the well-known json file from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n */\n\n\nfunction fetchWellKnownJson(baseUrl = \"/\", requestOptions) {\n  const url = String(baseUrl).replace(/\\/*$/, \"/\") + \".well-known/smart-configuration\";\n  return lib_1.getAndCache(url, requestOptions).catch(ex => {\n    throw new Error(`Failed to fetch the well-known json \"${url}\". ${ex.message}`);\n  });\n}\n\nexports.fetchWellKnownJson = fetchWellKnownJson;\n/**\n * Fetch a \"WellKnownJson\" and extract the SMART endpoints from it\n */\n\nfunction getSecurityExtensionsFromWellKnownJson(baseUrl = \"/\", requestOptions) {\n  return fetchWellKnownJson(baseUrl, requestOptions).then(meta => {\n    if (!meta.authorization_endpoint || !meta.token_endpoint) {\n      throw new Error(\"Invalid wellKnownJson\");\n    }\n\n    return {\n      registrationUri: meta.registration_endpoint || \"\",\n      authorizeUri: meta.authorization_endpoint,\n      tokenUri: meta.token_endpoint\n    };\n  });\n}\n/**\n * Fetch a `CapabilityStatement` and extract the SMART endpoints from it\n */\n\n\nfunction getSecurityExtensionsFromConformanceStatement(baseUrl = \"/\", requestOptions) {\n  return lib_1.fetchConformanceStatement(baseUrl, requestOptions).then(meta => {\n    const nsUri = \"http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris\";\n    const extensions = (lib_1.getPath(meta || {}, \"rest.0.security.extension\") || []).filter(e => e.url === nsUri).map(o => o.extension)[0];\n    const out = {\n      registrationUri: \"\",\n      authorizeUri: \"\",\n      tokenUri: \"\"\n    };\n\n    if (extensions) {\n      extensions.forEach(ext => {\n        if (ext.url === \"register\") {\n          out.registrationUri = ext.valueUri;\n        }\n\n        if (ext.url === \"authorize\") {\n          out.authorizeUri = ext.valueUri;\n        }\n\n        if (ext.url === \"token\") {\n          out.tokenUri = ext.valueUri;\n        }\n      });\n    }\n\n    return out;\n  });\n}\n/**\n * This works similarly to `Promise.any()`. The tasks are objects containing a\n * request promise and it's AbortController. Returns a promise that will be\n * resolved with the return value of the first successful request, or rejected\n * with an aggregate error if all tasks fail. Any requests, other than the first\n * one that succeeds will be aborted.\n */\n\n\nfunction any(tasks) {\n  const len = tasks.length;\n  const errors = [];\n  let resolved = false;\n  return new Promise((resolve, reject) => {\n    function onSuccess(task, result) {\n      task.complete = true;\n\n      if (!resolved) {\n        resolved = true;\n        tasks.forEach(t => {\n          if (!t.complete) {\n            t.controller.abort();\n          }\n        });\n        resolve(result);\n      }\n    }\n\n    function onError(error) {\n      if (errors.push(error) === len) {\n        reject(new Error(errors.map(e => e.message).join(\"; \")));\n      }\n    }\n\n    tasks.forEach(t => {\n      t.promise.then(result => onSuccess(t, result), onError);\n    });\n  });\n}\n/**\n * Given a FHIR server, returns an object with it's Oauth security endpoints\n * that we are interested in. This will try to find the info in both the\n * `CapabilityStatement` and the `.well-known/smart-configuration`. Whatever\n * Arrives first will be used and the other request will be aborted.\n * @param [baseUrl] Fhir server base URL\n * @param [env] The Adapter\n */\n\n\nfunction getSecurityExtensions(env, baseUrl = \"/\") {\n  const AbortController = env.getAbortController();\n  const abortController1 = new AbortController();\n  const abortController2 = new AbortController();\n  return any([{\n    controller: abortController1,\n    promise: getSecurityExtensionsFromWellKnownJson(baseUrl, {\n      signal: abortController1.signal\n    })\n  }, {\n    controller: abortController2,\n    promise: getSecurityExtensionsFromConformanceStatement(baseUrl, {\n      signal: abortController2.signal\n    })\n  }]);\n}\n\nexports.getSecurityExtensions = getSecurityExtensions;\n/**\n * Starts the SMART Launch Sequence.\n * > **IMPORTANT**:\n *   `authorize()` will end up redirecting you to the authorization server.\n *    This means that you should not add anything to the returned promise chain.\n *    Any code written directly after the authorize() call might not be executed\n *    due to that redirect!\n * @param env\n * @param [params]\n */\n\nasync function authorize(env, params = {}) {\n  const url = env.getUrl(); // Multiple config for EHR launches ---------------------------------------\n\n  if (Array.isArray(params)) {\n    const urlISS = url.searchParams.get(\"iss\") || url.searchParams.get(\"fhirServiceUrl\");\n\n    if (!urlISS) {\n      throw new Error('Passing in an \"iss\" url parameter is required if authorize ' + 'uses multiple configurations');\n    } // pick the right config\n\n\n    const cfg = params.find(x => {\n      if (x.issMatch) {\n        if (typeof x.issMatch === \"function\") {\n          return !!x.issMatch(urlISS);\n        }\n\n        if (typeof x.issMatch === \"string\") {\n          return x.issMatch === urlISS;\n        }\n\n        if (x.issMatch instanceof RegExp) {\n          return x.issMatch.test(urlISS);\n        }\n      }\n\n      return false;\n    });\n    lib_1.assert(cfg, `No configuration found matching the current \"iss\" parameter \"${urlISS}\"`);\n    return await authorize(env, cfg);\n  } // ------------------------------------------------------------------------\n  // Obtain input\n\n\n  const {\n    redirect_uri,\n    clientSecret,\n    fakeTokenResponse,\n    patientId,\n    encounterId,\n    client_id,\n    target,\n    width,\n    height\n  } = params;\n  let {\n    iss,\n    launch,\n    fhirServiceUrl,\n    redirectUri,\n    noRedirect,\n    scope = \"\",\n    clientId,\n    completeInTarget\n  } = params;\n  const storage = env.getStorage(); // For these three an url param takes precedence over inline option\n\n  iss = url.searchParams.get(\"iss\") || iss;\n  fhirServiceUrl = url.searchParams.get(\"fhirServiceUrl\") || fhirServiceUrl;\n  launch = url.searchParams.get(\"launch\") || launch;\n\n  if (!clientId) {\n    clientId = client_id;\n  }\n\n  if (!redirectUri) {\n    redirectUri = redirect_uri;\n  }\n\n  if (!redirectUri) {\n    redirectUri = env.relative(\".\");\n  } else if (!redirectUri.match(/^https?\\:\\/\\//)) {\n    redirectUri = env.relative(redirectUri);\n  }\n\n  const serverUrl = String(iss || fhirServiceUrl || \"\"); // Validate input\n\n  if (!serverUrl) {\n    throw new Error(\"No server url found. It must be specified as `iss` or as \" + \"`fhirServiceUrl` parameter\");\n  }\n\n  if (iss) {\n    debug(\"Making %s launch...\", launch ? \"EHR\" : \"standalone\");\n  } // append launch scope if needed\n\n\n  if (launch && !scope.match(/launch/)) {\n    scope += \" launch\";\n  }\n\n  if (isBrowser()) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp();\n\n    if ((inFrame || inPopUp) && completeInTarget !== true && completeInTarget !== false) {\n      // completeInTarget will default to true if authorize is called from\n      // within an iframe. This is to avoid issues when the entire app\n      // happens to be rendered in an iframe (including in some EHRs),\n      // even though that was not how the app developer's intention.\n      completeInTarget = inFrame; // In this case we can't always make the best decision so ask devs\n      // to be explicit in their configuration.\n\n      console.warn('Your app is being authorized from within an iframe or popup ' + 'window. Please be explicit and provide a \"completeInTarget\" ' + 'option. Use \"true\" to complete the authorization in the ' + 'same window, or \"false\" to try to complete it in the parent ' + 'or the opener window. See http://docs.smarthealthit.org/client-js/api.html');\n    }\n  } // If `authorize` is called, make sure we clear any previous state (in case\n  // this is a re-authorize)\n\n\n  const oldKey = await storage.get(settings_1.SMART_KEY);\n  await storage.unset(oldKey); // create initial state\n\n  const stateKey = lib_1.randomString(16);\n  const state = {\n    clientId,\n    scope,\n    redirectUri,\n    serverUrl,\n    clientSecret,\n    tokenResponse: {},\n    key: stateKey,\n    completeInTarget\n  };\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true;\n\n  if (fullSessionStorageSupport) {\n    await storage.set(settings_1.SMART_KEY, stateKey);\n  } // fakeTokenResponse to override stuff (useful in development)\n\n\n  if (fakeTokenResponse) {\n    Object.assign(state.tokenResponse, fakeTokenResponse);\n  } // Fixed patientId (useful in development)\n\n\n  if (patientId) {\n    Object.assign(state.tokenResponse, {\n      patient: patientId\n    });\n  } // Fixed encounterId (useful in development)\n\n\n  if (encounterId) {\n    Object.assign(state.tokenResponse, {\n      encounter: encounterId\n    });\n  }\n\n  let redirectUrl = redirectUri + \"?state=\" + encodeURIComponent(stateKey); // bypass oauth if fhirServiceUrl is used (but iss takes precedence)\n\n  if (fhirServiceUrl && !iss) {\n    debug(\"Making fake launch...\");\n    await storage.set(stateKey, state);\n\n    if (noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // Get oauth endpoints and add them to the state\n\n\n  const extensions = await getSecurityExtensions(env, serverUrl);\n  Object.assign(state, extensions);\n  await storage.set(stateKey, state); // If this happens to be an open server and there is no authorizeUri\n\n  if (!state.authorizeUri) {\n    if (noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // build the redirect uri\n\n\n  const redirectParams = [\"response_type=code\", \"client_id=\" + encodeURIComponent(clientId || \"\"), \"scope=\" + encodeURIComponent(scope), \"redirect_uri=\" + encodeURIComponent(redirectUri), \"aud=\" + encodeURIComponent(serverUrl), \"state=\" + encodeURIComponent(stateKey)]; // also pass this in case of EHR launch\n\n  if (launch) {\n    redirectParams.push(\"launch=\" + encodeURIComponent(launch));\n  }\n\n  redirectUrl = state.authorizeUri + \"?\" + redirectParams.join(\"&\");\n\n  if (noRedirect) {\n    return redirectUrl;\n  }\n\n  if (target && isBrowser()) {\n    let win;\n    win = await lib_1.getTargetWindow(target, width, height);\n\n    if (win !== self) {\n      try {\n        // Also remove any old state from the target window and then\n        // transfer the current state there\n        win.sessionStorage.removeItem(oldKey);\n        win.sessionStorage.setItem(stateKey, JSON.stringify(state));\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.sessionStorage. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        win = self;\n      }\n    }\n\n    if (win !== self) {\n      try {\n        win.location.href = redirectUrl;\n        self.addEventListener(\"message\", onMessage);\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.location. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        self.location.href = redirectUrl;\n      }\n    } else {\n      self.location.href = redirectUrl;\n    }\n\n    return;\n  } else {\n    return await env.redirect(redirectUrl);\n  }\n}\n\nexports.authorize = authorize;\n/**\n * Checks if called within a frame. Only works in browsers!\n * If the current window has a `parent` or `top` properties that refer to\n * another window, returns true. If trying to access `top` or `parent` throws an\n * error, returns true. Otherwise returns `false`.\n */\n\nfunction isInFrame() {\n  try {\n    return self !== top && parent !== self;\n  } catch (e) {\n    return true;\n  }\n}\n\nexports.isInFrame = isInFrame;\n/**\n * Checks if called within another window (popup or tab). Only works in browsers!\n * To consider itself called in a new window, this function verifies that:\n * 1. `self === top` (not in frame)\n * 2. `!!opener && opener !== self` The window has an opener\n * 3. `!!window.name` The window has a `name` set\n */\n\nfunction isInPopUp() {\n  try {\n    return self === top && !!opener && opener !== self && !!window.name;\n  } catch (e) {\n    return false;\n  }\n}\n\nexports.isInPopUp = isInPopUp;\n/**\n * Another window can send a \"completeAuth\" message to this one, making it to\n * navigate to e.data.url\n * @param e The message event\n */\n\nfunction onMessage(e) {\n  if (e.data.type == \"completeAuth\" && e.origin === new URL(self.location.href).origin) {\n    window.removeEventListener(\"message\", onMessage);\n    window.location.href = e.data.url;\n  }\n}\n\nexports.onMessage = onMessage;\n/**\n * The completeAuth function should only be called on the page that represents\n * the redirectUri. We typically land there after a redirect from the\n * authorization server..\n */\n\nasync function completeAuth(env) {\n  var _a, _b;\n\n  const url = env.getUrl();\n  const Storage = env.getStorage();\n  const params = url.searchParams;\n  let key = params.get(\"state\");\n  const code = params.get(\"code\");\n  const authError = params.get(\"error\");\n  const authErrorDescription = params.get(\"error_description\");\n\n  if (!key) {\n    key = await Storage.get(settings_1.SMART_KEY);\n  } // Start by checking the url for `error` and `error_description` parameters.\n  // This happens when the auth server rejects our authorization attempt. In\n  // this case it has no other way to tell us what the error was, other than\n  // appending these parameters to the redirect url.\n  // From client's point of view, this is not very reliable (because we can't\n  // know how we have landed on this page - was it a redirect or was it loaded\n  // manually). However, if `completeAuth()` is being called, we can assume\n  // that the url comes from the auth server (otherwise the app won't work\n  // anyway).\n\n\n  if (authError || authErrorDescription) {\n    throw new Error([authError, authErrorDescription].filter(Boolean).join(\": \"));\n  }\n\n  debug(\"key: %s, code: %s\", key, code); // key might be coming from the page url so it might be empty or missing\n\n  lib_1.assert(key, \"No 'state' parameter found. Please (re)launch the app.\"); // Check if we have a previous state\n\n  let state = await Storage.get(key);\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true; // If we are in a popup window or an iframe and the authorization is\n  // complete, send the location back to our opener and exit.\n\n  if (isBrowser() && state && !state.completeInTarget) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp(); // we are about to return to the opener/parent where completeAuth will\n    // be called again. In rare cases the opener or parent might also be\n    // a frame or popup. Then inFrame or inPopUp will be true but we still\n    // have to stop going up the chain. To guard against that weird form of\n    // recursion we pass one additional parameter to the url which we later\n    // remove.\n\n    if ((inFrame || inPopUp) && !url.searchParams.get(\"complete\")) {\n      url.searchParams.set(\"complete\", \"1\");\n      const {\n        href,\n        origin\n      } = url;\n\n      if (inFrame) {\n        parent.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n      }\n\n      if (inPopUp) {\n        opener.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n        window.close();\n      }\n\n      return new Promise(() => {});\n    }\n  }\n\n  url.searchParams.delete(\"complete\"); // Do we have to remove the `code` and `state` params from the URL?\n\n  const hasState = params.has(\"state\");\n\n  if (isBrowser() && lib_1.getPath(env, \"options.replaceBrowserHistory\") && (code || hasState)) {\n    // `code` is the flag that tell us to request an access token.\n    // We have to remove it, otherwise the page will authorize on\n    // every load!\n    if (code) {\n      params.delete(\"code\");\n      debug(\"Removed code parameter from the url.\");\n    } // If we have `fullSessionStorageSupport` it means we no longer\n    // need the `state` key. It will be stored to a well know\n    // location - sessionStorage[SMART_KEY]. However, no\n    // fullSessionStorageSupport means that this \"well know location\"\n    // might be shared between windows and tabs. In this case we\n    // MUST keep the `state` url parameter.\n\n\n    if (hasState && fullSessionStorageSupport) {\n      params.delete(\"state\");\n      debug(\"Removed state parameter from the url.\");\n    } // If the browser does not support the replaceState method for the\n    // History Web API, the \"code\" parameter cannot be removed. As a\n    // consequence, the page will (re)authorize on every load. The\n    // workaround is to reload the page to new location without those\n    // parameters. If that is not acceptable replaceBrowserHistory\n    // should be set to false.\n\n\n    if (window.history.replaceState) {\n      window.history.replaceState({}, \"\", url.href);\n    }\n  } // If the state does not exist, it means the page has been loaded directly.\n\n\n  lib_1.assert(state, \"No state found! Please (re)launch the app.\"); // Assume the client has already completed a token exchange when\n  // there is no code (but we have a state) or access token is found in state\n\n  const authorized = !code || ((_a = state.tokenResponse) === null || _a === void 0 ? void 0 : _a.access_token); // If we are authorized already, then this is just a reload.\n  // Otherwise, we have to complete the code flow\n\n  if (!authorized && state.tokenUri) {\n    lib_1.assert(code, \"'code' url parameter is required\");\n    debug(\"Preparing to exchange the code for access token...\");\n    const requestOptions = buildTokenRequest(env, code, state);\n    debug(\"Token request options: %O\", requestOptions); // The EHR authorization server SHALL return a JSON structure that\n    // includes an access token or a message indicating that the\n    // authorization request has been denied.\n\n    const tokenResponse = await lib_1.request(state.tokenUri, requestOptions);\n    debug(\"Token response: %O\", tokenResponse);\n    lib_1.assert(tokenResponse.access_token, \"Failed to obtain access token.\"); // Now we need to determine when is this authorization going to expire\n\n    state.expiresAt = lib_1.getAccessTokenExpiration(tokenResponse, env); // save the tokenResponse so that we don't have to re-authorize on\n    // every page reload\n\n    state = Object.assign(Object.assign({}, state), {\n      tokenResponse\n    });\n    await Storage.set(key, state);\n    debug(\"Authorization successful!\");\n  } else {\n    debug(((_b = state.tokenResponse) === null || _b === void 0 ? void 0 : _b.access_token) ? \"Already authorized\" : \"No authorization needed\");\n  }\n\n  if (fullSessionStorageSupport) {\n    await Storage.set(settings_1.SMART_KEY, key);\n  }\n\n  const client = new Client_1.default(env, state);\n  debug(\"Created client instance: %O\", client);\n  return client;\n}\n\nexports.completeAuth = completeAuth;\n/**\n * Builds the token request options. Does not make the request, just\n * creates it's configuration and returns it in a Promise.\n */\n\nfunction buildTokenRequest(env, code, state) {\n  const {\n    redirectUri,\n    clientSecret,\n    tokenUri,\n    clientId\n  } = state;\n  lib_1.assert(redirectUri, \"Missing state.redirectUri\");\n  lib_1.assert(tokenUri, \"Missing state.tokenUri\");\n  lib_1.assert(clientId, \"Missing state.clientId\");\n  const requestOptions = {\n    method: \"POST\",\n    headers: {\n      \"content-type\": \"application/x-www-form-urlencoded\"\n    },\n    body: `code=${code}&grant_type=authorization_code&redirect_uri=${encodeURIComponent(redirectUri)}`\n  }; // For public apps, authentication is not possible (and thus not required),\n  // since a client with no secret cannot prove its identity when it issues a\n  // call. (The end-to-end system can still be secure because the client comes\n  // from a known, https protected endpoint specified and enforced by the\n  // redirect uri.) For confidential apps, an Authorization header using HTTP\n  // Basic authentication is required, where the username is the app’s\n  // client_id and the password is the app’s client_secret (see example).\n\n  if (clientSecret) {\n    requestOptions.headers.Authorization = \"Basic \" + env.btoa(clientId + \":\" + clientSecret);\n    debug(\"Using state.clientSecret to construct the authorization header: %s\", requestOptions.headers.Authorization);\n  } else {\n    debug(\"No clientSecret found in state. Adding the clientId to the POST body\");\n    requestOptions.body += `&client_id=${encodeURIComponent(clientId)}`;\n  }\n\n  return requestOptions;\n}\n\nexports.buildTokenRequest = buildTokenRequest;\n/**\n * @param env\n * @param [onSuccess]\n * @param [onError]\n */\n\nasync function ready(env, onSuccess, onError) {\n  let task = completeAuth(env);\n\n  if (onSuccess) {\n    task = task.then(onSuccess);\n  }\n\n  if (onError) {\n    task = task.catch(onError);\n  }\n\n  return task;\n}\n\nexports.ready = ready;\n/**\n * This function can be used when you want to handle everything in one page\n * (no launch endpoint needed). You can think of it as if it does:\n * ```js\n * authorize(options).then(ready)\n * ```\n *\n * **Be careful with init()!** There are some details you need to be aware of:\n *\n * 1. It will only work if your launch_uri is the same as your redirect_uri.\n *    While this should be valid, we can’t promise that every EHR will allow you\n *    to register client with such settings.\n * 2. Internally, `init()` will be called twice. First it will redirect to the\n *    EHR, then the EHR will redirect back to the page where init() will be\n *    called again to complete the authorization. This is generally fine,\n *    because the returned promise will only be resolved once, after the second\n *    execution, but please also consider the following:\n *    - You should wrap all your app’s code in a function that is only executed\n *      after `init()` resolves!\n *    - Since the page will be loaded twice, you must be careful if your code\n *      has global side effects that can persist between page reloads\n *      (for example writing to localStorage).\n * 3. For standalone launch, only use init in combination with offline_access\n *    scope. Once the access_token expires, if you don’t have a refresh_token\n *    there is no way to re-authorize properly. We detect that and delete the\n *    expired access token, but it still means that the user will have to\n *    refresh the page twice to re-authorize.\n * @param env The adapter\n * @param options The authorize options\n */\n\nasync function init(env, options) {\n  const url = env.getUrl();\n  const code = url.searchParams.get(\"code\");\n  const state = url.searchParams.get(\"state\"); // if `code` and `state` params are present we need to complete the auth flow\n\n  if (code && state) {\n    return completeAuth(env);\n  } // Check for existing client state. If state is found, it means a client\n  // instance have already been created in this session and we should try to\n  // \"revive\" it.\n\n\n  const storage = env.getStorage();\n  const key = state || (await storage.get(settings_1.SMART_KEY));\n  const cached = await storage.get(key);\n\n  if (cached) {\n    return new Client_1.default(env, cached);\n  } // Otherwise try to launch\n\n\n  return authorize(env, options).then(() => {\n    // `init` promises a Client but that cannot happen in this case. The\n    // browser will be redirected (unload the page and be redirected back\n    // to it later and the same init function will be called again). On\n    // success, authorize will resolve with the redirect url but we don't\n    // want to return that from this promise chain because it is not a\n    // Client instance. At the same time, if authorize fails, we do want to\n    // pass the error to those waiting for a client instance.\n    return new Promise(() => {});\n  });\n}\n\nexports.init = init;","map":{"version":3,"sources":["/Users/rajvansia/Documents/GitHub/lab-4-react/node_modules/fhirclient/lib/smart.js"],"names":["Object","defineProperty","exports","value","init","ready","buildTokenRequest","completeAuth","onMessage","isInPopUp","isInFrame","authorize","getSecurityExtensions","fetchWellKnownJson","KEY","lib_1","require","Client_1","settings_1","enumerable","get","SMART_KEY","debug","extend","isBrowser","window","baseUrl","requestOptions","url","String","replace","getAndCache","catch","ex","Error","message","getSecurityExtensionsFromWellKnownJson","then","meta","authorization_endpoint","token_endpoint","registrationUri","registration_endpoint","authorizeUri","tokenUri","getSecurityExtensionsFromConformanceStatement","fetchConformanceStatement","nsUri","extensions","getPath","filter","e","map","o","extension","out","forEach","ext","valueUri","any","tasks","len","length","errors","resolved","Promise","resolve","reject","onSuccess","task","result","complete","t","controller","abort","onError","error","push","join","promise","env","AbortController","getAbortController","abortController1","abortController2","signal","params","getUrl","Array","isArray","urlISS","searchParams","cfg","find","x","issMatch","RegExp","test","assert","redirect_uri","clientSecret","fakeTokenResponse","patientId","encounterId","client_id","target","width","height","iss","launch","fhirServiceUrl","redirectUri","noRedirect","scope","clientId","completeInTarget","storage","getStorage","relative","match","serverUrl","inFrame","inPopUp","console","warn","oldKey","unset","stateKey","randomString","state","tokenResponse","key","fullSessionStorageSupport","set","assign","patient","encounter","redirectUrl","encodeURIComponent","redirect","redirectParams","win","getTargetWindow","self","sessionStorage","removeItem","setItem","JSON","stringify","location","href","addEventListener","top","parent","opener","name","data","type","origin","URL","removeEventListener","_a","_b","Storage","code","authError","authErrorDescription","Boolean","postMessage","close","delete","hasState","has","history","replaceState","authorized","access_token","request","expiresAt","getAccessTokenExpiration","client","default","method","headers","body","Authorization","btoa","options","cached"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.init = exports.ready = exports.buildTokenRequest = exports.completeAuth = exports.onMessage = exports.isInPopUp = exports.isInFrame = exports.authorize = exports.getSecurityExtensions = exports.fetchWellKnownJson = exports.KEY = void 0;\n/* global window */\n\nconst lib_1 = require(\"./lib\");\n\nconst Client_1 = require(\"./Client\");\n\nconst settings_1 = require(\"./settings\");\n\nObject.defineProperty(exports, \"KEY\", {\n  enumerable: true,\n  get: function () {\n    return settings_1.SMART_KEY;\n  }\n});\nconst debug = lib_1.debug.extend(\"oauth2\");\n\nfunction isBrowser() {\n  return typeof window === \"object\";\n}\n/**\n * Fetches the well-known json file from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n */\n\n\nfunction fetchWellKnownJson(baseUrl = \"/\", requestOptions) {\n  const url = String(baseUrl).replace(/\\/*$/, \"/\") + \".well-known/smart-configuration\";\n  return lib_1.getAndCache(url, requestOptions).catch(ex => {\n    throw new Error(`Failed to fetch the well-known json \"${url}\". ${ex.message}`);\n  });\n}\n\nexports.fetchWellKnownJson = fetchWellKnownJson;\n/**\n * Fetch a \"WellKnownJson\" and extract the SMART endpoints from it\n */\n\nfunction getSecurityExtensionsFromWellKnownJson(baseUrl = \"/\", requestOptions) {\n  return fetchWellKnownJson(baseUrl, requestOptions).then(meta => {\n    if (!meta.authorization_endpoint || !meta.token_endpoint) {\n      throw new Error(\"Invalid wellKnownJson\");\n    }\n\n    return {\n      registrationUri: meta.registration_endpoint || \"\",\n      authorizeUri: meta.authorization_endpoint,\n      tokenUri: meta.token_endpoint\n    };\n  });\n}\n/**\n * Fetch a `CapabilityStatement` and extract the SMART endpoints from it\n */\n\n\nfunction getSecurityExtensionsFromConformanceStatement(baseUrl = \"/\", requestOptions) {\n  return lib_1.fetchConformanceStatement(baseUrl, requestOptions).then(meta => {\n    const nsUri = \"http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris\";\n    const extensions = (lib_1.getPath(meta || {}, \"rest.0.security.extension\") || []).filter(e => e.url === nsUri).map(o => o.extension)[0];\n    const out = {\n      registrationUri: \"\",\n      authorizeUri: \"\",\n      tokenUri: \"\"\n    };\n\n    if (extensions) {\n      extensions.forEach(ext => {\n        if (ext.url === \"register\") {\n          out.registrationUri = ext.valueUri;\n        }\n\n        if (ext.url === \"authorize\") {\n          out.authorizeUri = ext.valueUri;\n        }\n\n        if (ext.url === \"token\") {\n          out.tokenUri = ext.valueUri;\n        }\n      });\n    }\n\n    return out;\n  });\n}\n/**\n * This works similarly to `Promise.any()`. The tasks are objects containing a\n * request promise and it's AbortController. Returns a promise that will be\n * resolved with the return value of the first successful request, or rejected\n * with an aggregate error if all tasks fail. Any requests, other than the first\n * one that succeeds will be aborted.\n */\n\n\nfunction any(tasks) {\n  const len = tasks.length;\n  const errors = [];\n  let resolved = false;\n  return new Promise((resolve, reject) => {\n    function onSuccess(task, result) {\n      task.complete = true;\n\n      if (!resolved) {\n        resolved = true;\n        tasks.forEach(t => {\n          if (!t.complete) {\n            t.controller.abort();\n          }\n        });\n        resolve(result);\n      }\n    }\n\n    function onError(error) {\n      if (errors.push(error) === len) {\n        reject(new Error(errors.map(e => e.message).join(\"; \")));\n      }\n    }\n\n    tasks.forEach(t => {\n      t.promise.then(result => onSuccess(t, result), onError);\n    });\n  });\n}\n/**\n * Given a FHIR server, returns an object with it's Oauth security endpoints\n * that we are interested in. This will try to find the info in both the\n * `CapabilityStatement` and the `.well-known/smart-configuration`. Whatever\n * Arrives first will be used and the other request will be aborted.\n * @param [baseUrl] Fhir server base URL\n * @param [env] The Adapter\n */\n\n\nfunction getSecurityExtensions(env, baseUrl = \"/\") {\n  const AbortController = env.getAbortController();\n  const abortController1 = new AbortController();\n  const abortController2 = new AbortController();\n  return any([{\n    controller: abortController1,\n    promise: getSecurityExtensionsFromWellKnownJson(baseUrl, {\n      signal: abortController1.signal\n    })\n  }, {\n    controller: abortController2,\n    promise: getSecurityExtensionsFromConformanceStatement(baseUrl, {\n      signal: abortController2.signal\n    })\n  }]);\n}\n\nexports.getSecurityExtensions = getSecurityExtensions;\n/**\n * Starts the SMART Launch Sequence.\n * > **IMPORTANT**:\n *   `authorize()` will end up redirecting you to the authorization server.\n *    This means that you should not add anything to the returned promise chain.\n *    Any code written directly after the authorize() call might not be executed\n *    due to that redirect!\n * @param env\n * @param [params]\n */\n\nasync function authorize(env, params = {}) {\n  const url = env.getUrl(); // Multiple config for EHR launches ---------------------------------------\n\n  if (Array.isArray(params)) {\n    const urlISS = url.searchParams.get(\"iss\") || url.searchParams.get(\"fhirServiceUrl\");\n\n    if (!urlISS) {\n      throw new Error('Passing in an \"iss\" url parameter is required if authorize ' + 'uses multiple configurations');\n    } // pick the right config\n\n\n    const cfg = params.find(x => {\n      if (x.issMatch) {\n        if (typeof x.issMatch === \"function\") {\n          return !!x.issMatch(urlISS);\n        }\n\n        if (typeof x.issMatch === \"string\") {\n          return x.issMatch === urlISS;\n        }\n\n        if (x.issMatch instanceof RegExp) {\n          return x.issMatch.test(urlISS);\n        }\n      }\n\n      return false;\n    });\n    lib_1.assert(cfg, `No configuration found matching the current \"iss\" parameter \"${urlISS}\"`);\n    return await authorize(env, cfg);\n  } // ------------------------------------------------------------------------\n  // Obtain input\n\n\n  const {\n    redirect_uri,\n    clientSecret,\n    fakeTokenResponse,\n    patientId,\n    encounterId,\n    client_id,\n    target,\n    width,\n    height\n  } = params;\n  let {\n    iss,\n    launch,\n    fhirServiceUrl,\n    redirectUri,\n    noRedirect,\n    scope = \"\",\n    clientId,\n    completeInTarget\n  } = params;\n  const storage = env.getStorage(); // For these three an url param takes precedence over inline option\n\n  iss = url.searchParams.get(\"iss\") || iss;\n  fhirServiceUrl = url.searchParams.get(\"fhirServiceUrl\") || fhirServiceUrl;\n  launch = url.searchParams.get(\"launch\") || launch;\n\n  if (!clientId) {\n    clientId = client_id;\n  }\n\n  if (!redirectUri) {\n    redirectUri = redirect_uri;\n  }\n\n  if (!redirectUri) {\n    redirectUri = env.relative(\".\");\n  } else if (!redirectUri.match(/^https?\\:\\/\\//)) {\n    redirectUri = env.relative(redirectUri);\n  }\n\n  const serverUrl = String(iss || fhirServiceUrl || \"\"); // Validate input\n\n  if (!serverUrl) {\n    throw new Error(\"No server url found. It must be specified as `iss` or as \" + \"`fhirServiceUrl` parameter\");\n  }\n\n  if (iss) {\n    debug(\"Making %s launch...\", launch ? \"EHR\" : \"standalone\");\n  } // append launch scope if needed\n\n\n  if (launch && !scope.match(/launch/)) {\n    scope += \" launch\";\n  }\n\n  if (isBrowser()) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp();\n\n    if ((inFrame || inPopUp) && completeInTarget !== true && completeInTarget !== false) {\n      // completeInTarget will default to true if authorize is called from\n      // within an iframe. This is to avoid issues when the entire app\n      // happens to be rendered in an iframe (including in some EHRs),\n      // even though that was not how the app developer's intention.\n      completeInTarget = inFrame; // In this case we can't always make the best decision so ask devs\n      // to be explicit in their configuration.\n\n      console.warn('Your app is being authorized from within an iframe or popup ' + 'window. Please be explicit and provide a \"completeInTarget\" ' + 'option. Use \"true\" to complete the authorization in the ' + 'same window, or \"false\" to try to complete it in the parent ' + 'or the opener window. See http://docs.smarthealthit.org/client-js/api.html');\n    }\n  } // If `authorize` is called, make sure we clear any previous state (in case\n  // this is a re-authorize)\n\n\n  const oldKey = await storage.get(settings_1.SMART_KEY);\n  await storage.unset(oldKey); // create initial state\n\n  const stateKey = lib_1.randomString(16);\n  const state = {\n    clientId,\n    scope,\n    redirectUri,\n    serverUrl,\n    clientSecret,\n    tokenResponse: {},\n    key: stateKey,\n    completeInTarget\n  };\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true;\n\n  if (fullSessionStorageSupport) {\n    await storage.set(settings_1.SMART_KEY, stateKey);\n  } // fakeTokenResponse to override stuff (useful in development)\n\n\n  if (fakeTokenResponse) {\n    Object.assign(state.tokenResponse, fakeTokenResponse);\n  } // Fixed patientId (useful in development)\n\n\n  if (patientId) {\n    Object.assign(state.tokenResponse, {\n      patient: patientId\n    });\n  } // Fixed encounterId (useful in development)\n\n\n  if (encounterId) {\n    Object.assign(state.tokenResponse, {\n      encounter: encounterId\n    });\n  }\n\n  let redirectUrl = redirectUri + \"?state=\" + encodeURIComponent(stateKey); // bypass oauth if fhirServiceUrl is used (but iss takes precedence)\n\n  if (fhirServiceUrl && !iss) {\n    debug(\"Making fake launch...\");\n    await storage.set(stateKey, state);\n\n    if (noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // Get oauth endpoints and add them to the state\n\n\n  const extensions = await getSecurityExtensions(env, serverUrl);\n  Object.assign(state, extensions);\n  await storage.set(stateKey, state); // If this happens to be an open server and there is no authorizeUri\n\n  if (!state.authorizeUri) {\n    if (noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // build the redirect uri\n\n\n  const redirectParams = [\"response_type=code\", \"client_id=\" + encodeURIComponent(clientId || \"\"), \"scope=\" + encodeURIComponent(scope), \"redirect_uri=\" + encodeURIComponent(redirectUri), \"aud=\" + encodeURIComponent(serverUrl), \"state=\" + encodeURIComponent(stateKey)]; // also pass this in case of EHR launch\n\n  if (launch) {\n    redirectParams.push(\"launch=\" + encodeURIComponent(launch));\n  }\n\n  redirectUrl = state.authorizeUri + \"?\" + redirectParams.join(\"&\");\n\n  if (noRedirect) {\n    return redirectUrl;\n  }\n\n  if (target && isBrowser()) {\n    let win;\n    win = await lib_1.getTargetWindow(target, width, height);\n\n    if (win !== self) {\n      try {\n        // Also remove any old state from the target window and then\n        // transfer the current state there\n        win.sessionStorage.removeItem(oldKey);\n        win.sessionStorage.setItem(stateKey, JSON.stringify(state));\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.sessionStorage. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        win = self;\n      }\n    }\n\n    if (win !== self) {\n      try {\n        win.location.href = redirectUrl;\n        self.addEventListener(\"message\", onMessage);\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.location. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        self.location.href = redirectUrl;\n      }\n    } else {\n      self.location.href = redirectUrl;\n    }\n\n    return;\n  } else {\n    return await env.redirect(redirectUrl);\n  }\n}\n\nexports.authorize = authorize;\n/**\n * Checks if called within a frame. Only works in browsers!\n * If the current window has a `parent` or `top` properties that refer to\n * another window, returns true. If trying to access `top` or `parent` throws an\n * error, returns true. Otherwise returns `false`.\n */\n\nfunction isInFrame() {\n  try {\n    return self !== top && parent !== self;\n  } catch (e) {\n    return true;\n  }\n}\n\nexports.isInFrame = isInFrame;\n/**\n * Checks if called within another window (popup or tab). Only works in browsers!\n * To consider itself called in a new window, this function verifies that:\n * 1. `self === top` (not in frame)\n * 2. `!!opener && opener !== self` The window has an opener\n * 3. `!!window.name` The window has a `name` set\n */\n\nfunction isInPopUp() {\n  try {\n    return self === top && !!opener && opener !== self && !!window.name;\n  } catch (e) {\n    return false;\n  }\n}\n\nexports.isInPopUp = isInPopUp;\n/**\n * Another window can send a \"completeAuth\" message to this one, making it to\n * navigate to e.data.url\n * @param e The message event\n */\n\nfunction onMessage(e) {\n  if (e.data.type == \"completeAuth\" && e.origin === new URL(self.location.href).origin) {\n    window.removeEventListener(\"message\", onMessage);\n    window.location.href = e.data.url;\n  }\n}\n\nexports.onMessage = onMessage;\n/**\n * The completeAuth function should only be called on the page that represents\n * the redirectUri. We typically land there after a redirect from the\n * authorization server..\n */\n\nasync function completeAuth(env) {\n  var _a, _b;\n\n  const url = env.getUrl();\n  const Storage = env.getStorage();\n  const params = url.searchParams;\n  let key = params.get(\"state\");\n  const code = params.get(\"code\");\n  const authError = params.get(\"error\");\n  const authErrorDescription = params.get(\"error_description\");\n\n  if (!key) {\n    key = await Storage.get(settings_1.SMART_KEY);\n  } // Start by checking the url for `error` and `error_description` parameters.\n  // This happens when the auth server rejects our authorization attempt. In\n  // this case it has no other way to tell us what the error was, other than\n  // appending these parameters to the redirect url.\n  // From client's point of view, this is not very reliable (because we can't\n  // know how we have landed on this page - was it a redirect or was it loaded\n  // manually). However, if `completeAuth()` is being called, we can assume\n  // that the url comes from the auth server (otherwise the app won't work\n  // anyway).\n\n\n  if (authError || authErrorDescription) {\n    throw new Error([authError, authErrorDescription].filter(Boolean).join(\": \"));\n  }\n\n  debug(\"key: %s, code: %s\", key, code); // key might be coming from the page url so it might be empty or missing\n\n  lib_1.assert(key, \"No 'state' parameter found. Please (re)launch the app.\"); // Check if we have a previous state\n\n  let state = await Storage.get(key);\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true; // If we are in a popup window or an iframe and the authorization is\n  // complete, send the location back to our opener and exit.\n\n  if (isBrowser() && state && !state.completeInTarget) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp(); // we are about to return to the opener/parent where completeAuth will\n    // be called again. In rare cases the opener or parent might also be\n    // a frame or popup. Then inFrame or inPopUp will be true but we still\n    // have to stop going up the chain. To guard against that weird form of\n    // recursion we pass one additional parameter to the url which we later\n    // remove.\n\n    if ((inFrame || inPopUp) && !url.searchParams.get(\"complete\")) {\n      url.searchParams.set(\"complete\", \"1\");\n      const {\n        href,\n        origin\n      } = url;\n\n      if (inFrame) {\n        parent.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n      }\n\n      if (inPopUp) {\n        opener.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n        window.close();\n      }\n\n      return new Promise(() => {});\n    }\n  }\n\n  url.searchParams.delete(\"complete\"); // Do we have to remove the `code` and `state` params from the URL?\n\n  const hasState = params.has(\"state\");\n\n  if (isBrowser() && lib_1.getPath(env, \"options.replaceBrowserHistory\") && (code || hasState)) {\n    // `code` is the flag that tell us to request an access token.\n    // We have to remove it, otherwise the page will authorize on\n    // every load!\n    if (code) {\n      params.delete(\"code\");\n      debug(\"Removed code parameter from the url.\");\n    } // If we have `fullSessionStorageSupport` it means we no longer\n    // need the `state` key. It will be stored to a well know\n    // location - sessionStorage[SMART_KEY]. However, no\n    // fullSessionStorageSupport means that this \"well know location\"\n    // might be shared between windows and tabs. In this case we\n    // MUST keep the `state` url parameter.\n\n\n    if (hasState && fullSessionStorageSupport) {\n      params.delete(\"state\");\n      debug(\"Removed state parameter from the url.\");\n    } // If the browser does not support the replaceState method for the\n    // History Web API, the \"code\" parameter cannot be removed. As a\n    // consequence, the page will (re)authorize on every load. The\n    // workaround is to reload the page to new location without those\n    // parameters. If that is not acceptable replaceBrowserHistory\n    // should be set to false.\n\n\n    if (window.history.replaceState) {\n      window.history.replaceState({}, \"\", url.href);\n    }\n  } // If the state does not exist, it means the page has been loaded directly.\n\n\n  lib_1.assert(state, \"No state found! Please (re)launch the app.\"); // Assume the client has already completed a token exchange when\n  // there is no code (but we have a state) or access token is found in state\n\n  const authorized = !code || ((_a = state.tokenResponse) === null || _a === void 0 ? void 0 : _a.access_token); // If we are authorized already, then this is just a reload.\n  // Otherwise, we have to complete the code flow\n\n  if (!authorized && state.tokenUri) {\n    lib_1.assert(code, \"'code' url parameter is required\");\n    debug(\"Preparing to exchange the code for access token...\");\n    const requestOptions = buildTokenRequest(env, code, state);\n    debug(\"Token request options: %O\", requestOptions); // The EHR authorization server SHALL return a JSON structure that\n    // includes an access token or a message indicating that the\n    // authorization request has been denied.\n\n    const tokenResponse = await lib_1.request(state.tokenUri, requestOptions);\n    debug(\"Token response: %O\", tokenResponse);\n    lib_1.assert(tokenResponse.access_token, \"Failed to obtain access token.\"); // Now we need to determine when is this authorization going to expire\n\n    state.expiresAt = lib_1.getAccessTokenExpiration(tokenResponse, env); // save the tokenResponse so that we don't have to re-authorize on\n    // every page reload\n\n    state = Object.assign(Object.assign({}, state), {\n      tokenResponse\n    });\n    await Storage.set(key, state);\n    debug(\"Authorization successful!\");\n  } else {\n    debug(((_b = state.tokenResponse) === null || _b === void 0 ? void 0 : _b.access_token) ? \"Already authorized\" : \"No authorization needed\");\n  }\n\n  if (fullSessionStorageSupport) {\n    await Storage.set(settings_1.SMART_KEY, key);\n  }\n\n  const client = new Client_1.default(env, state);\n  debug(\"Created client instance: %O\", client);\n  return client;\n}\n\nexports.completeAuth = completeAuth;\n/**\n * Builds the token request options. Does not make the request, just\n * creates it's configuration and returns it in a Promise.\n */\n\nfunction buildTokenRequest(env, code, state) {\n  const {\n    redirectUri,\n    clientSecret,\n    tokenUri,\n    clientId\n  } = state;\n  lib_1.assert(redirectUri, \"Missing state.redirectUri\");\n  lib_1.assert(tokenUri, \"Missing state.tokenUri\");\n  lib_1.assert(clientId, \"Missing state.clientId\");\n  const requestOptions = {\n    method: \"POST\",\n    headers: {\n      \"content-type\": \"application/x-www-form-urlencoded\"\n    },\n    body: `code=${code}&grant_type=authorization_code&redirect_uri=${encodeURIComponent(redirectUri)}`\n  }; // For public apps, authentication is not possible (and thus not required),\n  // since a client with no secret cannot prove its identity when it issues a\n  // call. (The end-to-end system can still be secure because the client comes\n  // from a known, https protected endpoint specified and enforced by the\n  // redirect uri.) For confidential apps, an Authorization header using HTTP\n  // Basic authentication is required, where the username is the app’s\n  // client_id and the password is the app’s client_secret (see example).\n\n  if (clientSecret) {\n    requestOptions.headers.Authorization = \"Basic \" + env.btoa(clientId + \":\" + clientSecret);\n    debug(\"Using state.clientSecret to construct the authorization header: %s\", requestOptions.headers.Authorization);\n  } else {\n    debug(\"No clientSecret found in state. Adding the clientId to the POST body\");\n    requestOptions.body += `&client_id=${encodeURIComponent(clientId)}`;\n  }\n\n  return requestOptions;\n}\n\nexports.buildTokenRequest = buildTokenRequest;\n/**\n * @param env\n * @param [onSuccess]\n * @param [onError]\n */\n\nasync function ready(env, onSuccess, onError) {\n  let task = completeAuth(env);\n\n  if (onSuccess) {\n    task = task.then(onSuccess);\n  }\n\n  if (onError) {\n    task = task.catch(onError);\n  }\n\n  return task;\n}\n\nexports.ready = ready;\n/**\n * This function can be used when you want to handle everything in one page\n * (no launch endpoint needed). You can think of it as if it does:\n * ```js\n * authorize(options).then(ready)\n * ```\n *\n * **Be careful with init()!** There are some details you need to be aware of:\n *\n * 1. It will only work if your launch_uri is the same as your redirect_uri.\n *    While this should be valid, we can’t promise that every EHR will allow you\n *    to register client with such settings.\n * 2. Internally, `init()` will be called twice. First it will redirect to the\n *    EHR, then the EHR will redirect back to the page where init() will be\n *    called again to complete the authorization. This is generally fine,\n *    because the returned promise will only be resolved once, after the second\n *    execution, but please also consider the following:\n *    - You should wrap all your app’s code in a function that is only executed\n *      after `init()` resolves!\n *    - Since the page will be loaded twice, you must be careful if your code\n *      has global side effects that can persist between page reloads\n *      (for example writing to localStorage).\n * 3. For standalone launch, only use init in combination with offline_access\n *    scope. Once the access_token expires, if you don’t have a refresh_token\n *    there is no way to re-authorize properly. We detect that and delete the\n *    expired access token, but it still means that the user will have to\n *    refresh the page twice to re-authorize.\n * @param env The adapter\n * @param options The authorize options\n */\n\nasync function init(env, options) {\n  const url = env.getUrl();\n  const code = url.searchParams.get(\"code\");\n  const state = url.searchParams.get(\"state\"); // if `code` and `state` params are present we need to complete the auth flow\n\n  if (code && state) {\n    return completeAuth(env);\n  } // Check for existing client state. If state is found, it means a client\n  // instance have already been created in this session and we should try to\n  // \"revive\" it.\n\n\n  const storage = env.getStorage();\n  const key = state || (await storage.get(settings_1.SMART_KEY));\n  const cached = await storage.get(key);\n\n  if (cached) {\n    return new Client_1.default(env, cached);\n  } // Otherwise try to launch\n\n\n  return authorize(env, options).then(() => {\n    // `init` promises a Client but that cannot happen in this case. The\n    // browser will be redirected (unload the page and be redirected back\n    // to it later and the same init function will be called again). On\n    // success, authorize will resolve with the redirect url but we don't\n    // want to return that from this promise chain because it is not a\n    // Client instance. At the same time, if authorize fails, we do want to\n    // pass the error to those waiting for a client instance.\n    return new Promise(() => {});\n  });\n}\n\nexports.init = init;"]},"metadata":{},"sourceType":"script"}
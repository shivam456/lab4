{"ast":null,"code":"\"use strict\";\n\n// In Browsers we create an adapter, get the SMART api from it and build the\n// global FHIR object\nconst BrowserAdapter_1 = require(\"../adapters/BrowserAdapter\");\nconst adapter = new BrowserAdapter_1.default();\nconst {\n  ready,\n  authorize,\n  init,\n  client,\n  options,\n  utils\n} = adapter.getSmartApi(); // We have two kinds of browser builds - \"pure\" for new browsers and \"legacy\"\n// for old ones. In pure builds we assume that the browser supports everything\n// we need. In legacy mode, the library also acts as a polyfill. Babel will\n// automatically polyfill everything except \"fetch\", which we have to handle\n// manually.\n// @ts-ignore\n\nif (typeof FHIRCLIENT_PURE == \"undefined\") {\n  const fetch = require(\"cross-fetch\");\n  require(\"abortcontroller-polyfill/dist/abortcontroller-polyfill-only\");\n  if (!window.fetch) {\n    window.fetch = fetch.default;\n    window.Headers = fetch.Headers;\n    window.Request = fetch.Request;\n    window.Response = fetch.Response;\n  }\n} // $lab:coverage:off$\n\nconst FHIR = {\n  AbortController: window.AbortController,\n  client,\n  utils,\n  oauth2: {\n    settings: options,\n    ready,\n    authorize,\n    init\n  }\n};\nmodule.exports = FHIR; // $lab:coverage:on$","map":{"version":3,"names":["BrowserAdapter_1","require","adapter","default","ready","authorize","init","client","options","utils","getSmartApi","FHIRCLIENT_PURE","fetch","window","Headers","Request","Response","FHIR","AbortController","oauth2","settings","module","exports"],"sources":["/Users/shivamrustogi/Documents/GitHub/lab4/node_modules/fhirclient/lib/entry/browser.js"],"sourcesContent":["\"use strict\"; // In Browsers we create an adapter, get the SMART api from it and build the\n// global FHIR object\n\nconst BrowserAdapter_1 = require(\"../adapters/BrowserAdapter\");\n\nconst adapter = new BrowserAdapter_1.default();\nconst {\n  ready,\n  authorize,\n  init,\n  client,\n  options,\n  utils\n} = adapter.getSmartApi(); // We have two kinds of browser builds - \"pure\" for new browsers and \"legacy\"\n// for old ones. In pure builds we assume that the browser supports everything\n// we need. In legacy mode, the library also acts as a polyfill. Babel will\n// automatically polyfill everything except \"fetch\", which we have to handle\n// manually.\n// @ts-ignore\n\nif (typeof FHIRCLIENT_PURE == \"undefined\") {\n  const fetch = require(\"cross-fetch\");\n\n  require(\"abortcontroller-polyfill/dist/abortcontroller-polyfill-only\");\n\n  if (!window.fetch) {\n    window.fetch = fetch.default;\n    window.Headers = fetch.Headers;\n    window.Request = fetch.Request;\n    window.Response = fetch.Response;\n  }\n} // $lab:coverage:off$\n\n\nconst FHIR = {\n  AbortController: window.AbortController,\n  client,\n  utils,\n  oauth2: {\n    settings: options,\n    ready,\n    authorize,\n    init\n  }\n};\nmodule.exports = FHIR; // $lab:coverage:on$"],"mappings":"AAAA,YAAY;;AAAE;AACd;AAEA,MAAMA,gBAAgB,GAAGC,OAAO,CAAC,4BAA4B,CAAC;AAE9D,MAAMC,OAAO,GAAG,IAAIF,gBAAgB,CAACG,OAAO,EAAE;AAC9C,MAAM;EACJC,KAAK;EACLC,SAAS;EACTC,IAAI;EACJC,MAAM;EACNC,OAAO;EACPC;AACF,CAAC,GAAGP,OAAO,CAACQ,WAAW,EAAE,CAAC,CAAC;AAC3B;AACA;AACA;AACA;AACA;;AAEA,IAAI,OAAOC,eAAe,IAAI,WAAW,EAAE;EACzC,MAAMC,KAAK,GAAGX,OAAO,CAAC,aAAa,CAAC;EAEpCA,OAAO,CAAC,6DAA6D,CAAC;EAEtE,IAAI,CAACY,MAAM,CAACD,KAAK,EAAE;IACjBC,MAAM,CAACD,KAAK,GAAGA,KAAK,CAACT,OAAO;IAC5BU,MAAM,CAACC,OAAO,GAAGF,KAAK,CAACE,OAAO;IAC9BD,MAAM,CAACE,OAAO,GAAGH,KAAK,CAACG,OAAO;IAC9BF,MAAM,CAACG,QAAQ,GAAGJ,KAAK,CAACI,QAAQ;EAClC;AACF,CAAC,CAAC;;AAGF,MAAMC,IAAI,GAAG;EACXC,eAAe,EAAEL,MAAM,CAACK,eAAe;EACvCX,MAAM;EACNE,KAAK;EACLU,MAAM,EAAE;IACNC,QAAQ,EAAEZ,OAAO;IACjBJ,KAAK;IACLC,SAAS;IACTC;EACF;AACF,CAAC;AACDe,MAAM,CAACC,OAAO,GAAGL,IAAI,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport * as React from 'react';\nimport { isFragment } from 'react-is';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { refType } from '@material-ui/utils';\nimport debounce from '../utils/debounce';\nimport ownerWindow from '../utils/ownerWindow';\nimport { getNormalizedScrollLeft, detectScrollType } from '../utils/scrollLeft';\nimport animate from '../internal/animate';\nimport ScrollbarSize from './ScrollbarSize';\nimport withStyles from '../styles/withStyles';\nimport TabIndicator from './TabIndicator';\nimport TabScrollButton from '../TabScrollButton';\nimport useEventCallback from '../utils/useEventCallback';\nimport useTheme from '../styles/useTheme';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nexport const styles = theme => ({\n  /* Styles applied to the root element. */\n  root: {\n    overflow: 'hidden',\n    minHeight: 48,\n    WebkitOverflowScrolling: 'touch',\n    // Add iOS momentum scrolling.\n    display: 'flex'\n  },\n  /* Styles applied to the root element if `orientation=\"vertical\"`. */\n  vertical: {\n    flexDirection: 'column'\n  },\n  /* Styles applied to the flex container element. */\n  flexContainer: {\n    display: 'flex'\n  },\n  /* Styles applied to the flex container element if `orientation=\"vertical\"`. */\n  flexContainerVertical: {\n    flexDirection: 'column'\n  },\n  /* Styles applied to the flex container element if `centered={true}` & `!variant=\"scrollable\"`. */\n  centered: {\n    justifyContent: 'center'\n  },\n  /* Styles applied to the tablist element. */\n  scroller: {\n    position: 'relative',\n    display: 'inline-block',\n    flex: '1 1 auto',\n    whiteSpace: 'nowrap'\n  },\n  /* Styles applied to the tablist element if `!variant=\"scrollable\"`\b\b\b. */\n  fixed: {\n    overflowX: 'hidden',\n    width: '100%'\n  },\n  /* Styles applied to the tablist element if `variant=\"scrollable\"` and `orientation=\"horizontal\"`. */\n  scrollableX: {\n    overflowX: 'auto',\n    overflowY: 'hidden'\n  },\n  /* Styles applied to the tablist element if `variant=\"scrollable\"` and `orientation=\"vertical\"`. */\n  scrollableY: {\n    overflowY: 'auto',\n    overflowX: 'hidden'\n  },\n  /* Styles applied to the tablist element if `variant=\"scrollable\"` and `visibleScrollbar={false}`. */\n  hideScrollbar: {\n    // Hide dimensionless scrollbar on MacOS\n    scrollbarWidth: 'none',\n    // Firefox\n    '&::-webkit-scrollbar': {\n      display: 'none' // Safari + Chrome\n    }\n  },\n\n  /* Styles applied to the ScrollButtonComponent component. */\n  scrollButtons: {},\n  /* Styles applied to the ScrollButtonComponent component if `allowScrollButtonsMobile={true}`. */\n  scrollButtonsHideMobile: {\n    [theme.breakpoints.down('sm')]: {\n      display: 'none'\n    }\n  },\n  /* Styles applied to the TabIndicator component. */\n  indicator: {}\n});\nconst Tabs = /*#__PURE__*/React.forwardRef(function Tabs(props, ref) {\n  const {\n      'aria-label': ariaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      action,\n      centered = false,\n      children: childrenProp,\n      classes,\n      className,\n      component: Component = 'div',\n      allowScrollButtonsMobile = false,\n      indicatorColor = 'primary',\n      onChange,\n      orientation = 'horizontal',\n      ScrollButtonComponent = TabScrollButton,\n      scrollButtons = 'auto',\n      selectionFollowsFocus,\n      TabIndicatorProps = {},\n      TabScrollButtonProps,\n      textColor = 'primary',\n      value,\n      variant = 'standard',\n      visibleScrollbar = false\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, [\"aria-label\", \"aria-labelledby\", \"action\", \"centered\", \"children\", \"classes\", \"className\", \"component\", \"allowScrollButtonsMobile\", \"indicatorColor\", \"onChange\", \"orientation\", \"ScrollButtonComponent\", \"scrollButtons\", \"selectionFollowsFocus\", \"TabIndicatorProps\", \"TabScrollButtonProps\", \"textColor\", \"value\", \"variant\", \"visibleScrollbar\"]);\n  const theme = useTheme();\n  const scrollable = variant === 'scrollable';\n  const isRtl = theme.direction === 'rtl';\n  const vertical = orientation === 'vertical';\n  const scrollStart = vertical ? 'scrollTop' : 'scrollLeft';\n  const start = vertical ? 'top' : 'left';\n  const end = vertical ? 'bottom' : 'right';\n  const clientSize = vertical ? 'clientHeight' : 'clientWidth';\n  const size = vertical ? 'height' : 'width';\n  if (process.env.NODE_ENV !== 'production') {\n    if (centered && scrollable) {\n      console.error('Material-UI: You can not use the `centered={true}` and `variant=\"scrollable\"` properties ' + 'at the same time on a `Tabs` component.');\n    }\n  }\n  const [mounted, setMounted] = React.useState(false);\n  const [indicatorStyle, setIndicatorStyle] = React.useState({});\n  const [displayScroll, setDisplayScroll] = React.useState({\n    start: false,\n    end: false\n  });\n  const [scrollerStyle, setScrollerStyle] = React.useState({\n    overflow: 'hidden',\n    scrollbarWidth: 0\n  });\n  const valueToIndex = new Map();\n  const tabsRef = React.useRef(null);\n  const tabListRef = React.useRef(null);\n  const getTabsMeta = () => {\n    const tabsNode = tabsRef.current;\n    let tabsMeta;\n    if (tabsNode) {\n      const rect = tabsNode.getBoundingClientRect(); // create a new object with ClientRect class props + scrollLeft\n\n      tabsMeta = {\n        clientWidth: tabsNode.clientWidth,\n        scrollLeft: tabsNode.scrollLeft,\n        scrollTop: tabsNode.scrollTop,\n        scrollLeftNormalized: getNormalizedScrollLeft(tabsNode, theme.direction),\n        scrollWidth: tabsNode.scrollWidth,\n        top: rect.top,\n        bottom: rect.bottom,\n        left: rect.left,\n        right: rect.right\n      };\n    }\n    let tabMeta;\n    if (tabsNode && value !== false) {\n      const children = tabListRef.current.children;\n      if (children.length > 0) {\n        const tab = children[valueToIndex.get(value)];\n        if (process.env.NODE_ENV !== 'production') {\n          if (!tab) {\n            console.error([`Material-UI: The value provided to the Tabs component is invalid.`, `None of the Tabs' children match with \\`${value}\\`.`, valueToIndex.keys ? `You can provide one of the following values: ${Array.from(valueToIndex.keys()).join(', ')}.` : null].join('\\n'));\n          }\n        }\n        tabMeta = tab ? tab.getBoundingClientRect() : null;\n      }\n    }\n    return {\n      tabsMeta,\n      tabMeta\n    };\n  };\n  const updateIndicatorState = useEventCallback(() => {\n    const {\n      tabsMeta,\n      tabMeta\n    } = getTabsMeta();\n    let startValue = 0;\n    if (tabMeta && tabsMeta) {\n      if (vertical) {\n        startValue = tabMeta.top - tabsMeta.top + tabsMeta.scrollTop;\n      } else {\n        const correction = isRtl ? tabsMeta.scrollLeftNormalized + tabsMeta.clientWidth - tabsMeta.scrollWidth : tabsMeta.scrollLeft;\n        startValue = tabMeta.left - tabsMeta.left + correction;\n      }\n    }\n    const newIndicatorStyle = {\n      [start]: startValue,\n      // May be wrong until the font is loaded.\n      [size]: tabMeta ? tabMeta[size] : 0\n    }; // IE11 support, replace with Number.isNaN\n    // eslint-disable-next-line no-restricted-globals\n\n    if (isNaN(indicatorStyle[start]) || isNaN(indicatorStyle[size])) {\n      setIndicatorStyle(newIndicatorStyle);\n    } else {\n      const dStart = Math.abs(indicatorStyle[start] - newIndicatorStyle[start]);\n      const dSize = Math.abs(indicatorStyle[size] - newIndicatorStyle[size]);\n      if (dStart >= 1 || dSize >= 1) {\n        setIndicatorStyle(newIndicatorStyle);\n      }\n    }\n  });\n  const scroll = scrollValue => {\n    animate(scrollStart, tabsRef.current, scrollValue);\n  };\n  const moveTabsScroll = delta => {\n    let scrollValue = tabsRef.current[scrollStart];\n    if (vertical) {\n      scrollValue += delta;\n    } else {\n      scrollValue += delta * (isRtl ? -1 : 1); // Fix for Edge\n\n      scrollValue *= isRtl && detectScrollType() === 'reverse' ? -1 : 1;\n    }\n    scroll(scrollValue);\n  };\n  const getScrollSize = () => {\n    const containerSize = tabsRef.current[clientSize];\n    let totalSize = 0;\n    const children = Array.from(tabListRef.current.children);\n    for (let i = 0; i < children.length; i += 1) {\n      const tab = children[i];\n      if (totalSize + tab[clientSize] > containerSize) {\n        break;\n      }\n      totalSize += tab[clientSize];\n    }\n    return totalSize;\n  };\n  const handleStartScrollClick = () => {\n    moveTabsScroll(-1 * getScrollSize());\n  };\n  const handleEndScrollClick = () => {\n    moveTabsScroll(getScrollSize());\n  }; // TODO Remove <ScrollbarSize /> as browser support for hidding the scrollbar\n  // with CSS improves.\n\n  const handleScrollbarSizeChange = React.useCallback(scrollbarWidth => {\n    setScrollerStyle({\n      overflow: null,\n      scrollbarWidth\n    });\n  }, []);\n  const getConditionalElements = () => {\n    const conditionalElements = {};\n    conditionalElements.scrollbarSizeListener = scrollable ? /*#__PURE__*/_jsx(ScrollbarSize, {\n      onChange: handleScrollbarSizeChange,\n      className: clsx(classes.scrollableX, classes.hideScrollbar)\n    }) : null;\n    const scrollButtonsActive = displayScroll.start || displayScroll.end;\n    const showScrollButtons = scrollable && (scrollButtons === 'auto' && scrollButtonsActive || scrollButtons === true);\n    conditionalElements.scrollButtonStart = showScrollButtons ? /*#__PURE__*/_jsx(ScrollButtonComponent, _extends({\n      orientation: orientation,\n      direction: isRtl ? 'right' : 'left',\n      onClick: handleStartScrollClick,\n      disabled: !displayScroll.start,\n      className: clsx(classes.scrollButtons, !allowScrollButtonsMobile && classes.scrollButtonsHideMobile)\n    }, TabScrollButtonProps)) : null;\n    conditionalElements.scrollButtonEnd = showScrollButtons ? /*#__PURE__*/_jsx(ScrollButtonComponent, _extends({\n      orientation: orientation,\n      direction: isRtl ? 'left' : 'right',\n      onClick: handleEndScrollClick,\n      disabled: !displayScroll.end,\n      className: clsx(classes.scrollButtons, !allowScrollButtonsMobile && classes.scrollButtonsHideMobile)\n    }, TabScrollButtonProps)) : null;\n    return conditionalElements;\n  };\n  const scrollSelectedIntoView = useEventCallback(() => {\n    const {\n      tabsMeta,\n      tabMeta\n    } = getTabsMeta();\n    if (!tabMeta || !tabsMeta) {\n      return;\n    }\n    if (tabMeta[start] < tabsMeta[start]) {\n      // left side of button is out of view\n      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[start] - tabsMeta[start]);\n      scroll(nextScrollStart);\n    } else if (tabMeta[end] > tabsMeta[end]) {\n      // right side of button is out of view\n      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[end] - tabsMeta[end]);\n      scroll(nextScrollStart);\n    }\n  });\n  const updateScrollButtonState = useEventCallback(() => {\n    if (scrollable && scrollButtons !== false) {\n      const {\n        scrollTop,\n        scrollHeight,\n        clientHeight,\n        scrollWidth,\n        clientWidth\n      } = tabsRef.current;\n      let showStartScroll;\n      let showEndScroll;\n      if (vertical) {\n        showStartScroll = scrollTop > 1;\n        showEndScroll = scrollTop < scrollHeight - clientHeight - 1;\n      } else {\n        const scrollLeft = getNormalizedScrollLeft(tabsRef.current, theme.direction); // use 1 for the potential rounding error with browser zooms.\n\n        showStartScroll = isRtl ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;\n        showEndScroll = !isRtl ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;\n      }\n      if (showStartScroll !== displayScroll.start || showEndScroll !== displayScroll.end) {\n        setDisplayScroll({\n          start: showStartScroll,\n          end: showEndScroll\n        });\n      }\n    }\n  });\n  React.useEffect(() => {\n    const handleResize = debounce(() => {\n      updateIndicatorState();\n      updateScrollButtonState();\n    });\n    const win = ownerWindow(tabsRef.current);\n    win.addEventListener('resize', handleResize);\n    return () => {\n      handleResize.clear();\n      win.removeEventListener('resize', handleResize);\n    };\n  }, [updateIndicatorState, updateScrollButtonState]);\n  const handleTabsScroll = React.useMemo(() => debounce(() => {\n    updateScrollButtonState();\n  }), [updateScrollButtonState]);\n  React.useEffect(() => {\n    return () => {\n      handleTabsScroll.clear();\n    };\n  }, [handleTabsScroll]);\n  React.useEffect(() => {\n    setMounted(true);\n  }, []);\n  React.useEffect(() => {\n    updateIndicatorState();\n    updateScrollButtonState();\n  });\n  React.useEffect(() => {\n    scrollSelectedIntoView();\n  }, [scrollSelectedIntoView, indicatorStyle]);\n  React.useImperativeHandle(action, () => ({\n    updateIndicator: updateIndicatorState,\n    updateScrollButtons: updateScrollButtonState\n  }), [updateIndicatorState, updateScrollButtonState]);\n  const indicator = /*#__PURE__*/_jsx(TabIndicator, _extends({\n    className: classes.indicator,\n    orientation: orientation,\n    color: indicatorColor\n  }, TabIndicatorProps, {\n    style: _extends({}, indicatorStyle, TabIndicatorProps.style)\n  }));\n  let childIndex = 0;\n  const children = React.Children.map(childrenProp, child => {\n    if (! /*#__PURE__*/React.isValidElement(child)) {\n      return null;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (isFragment(child)) {\n        console.error([\"Material-UI: The Tabs component doesn't accept a Fragment as a child.\", 'Consider providing an array instead.'].join('\\n'));\n      }\n    }\n    const childValue = child.props.value === undefined ? childIndex : child.props.value;\n    valueToIndex.set(childValue, childIndex);\n    const selected = childValue === value;\n    childIndex += 1;\n    return /*#__PURE__*/React.cloneElement(child, _extends({\n      fullWidth: variant === 'fullWidth',\n      indicator: selected && !mounted && indicator,\n      selected,\n      selectionFollowsFocus,\n      onChange,\n      textColor,\n      value: childValue\n    }, childIndex === 1 && value === false && !child.props.tabIndex ? {\n      tabIndex: 0\n    } : {}));\n  });\n  const handleKeyDown = event => {\n    const {\n      target\n    } = event; // Keyboard navigation assumes that [role=\"tab\"] are siblings\n    // though we might warn in the future about nested, interactive elements\n    // as a a11y violation\n\n    const role = target.getAttribute('role');\n    if (role !== 'tab') {\n      return;\n    }\n    let newFocusTarget = null;\n    let previousItemKey = orientation !== \"vertical\" ? 'ArrowLeft' : 'ArrowUp';\n    let nextItemKey = orientation !== \"vertical\" ? 'ArrowRight' : 'ArrowDown';\n    if (orientation !== \"vertical\" && theme.direction === 'rtl') {\n      // swap previousItemKey with nextItemKey\n      previousItemKey = 'ArrowRight';\n      nextItemKey = 'ArrowLeft';\n    }\n    switch (event.key) {\n      case previousItemKey:\n        newFocusTarget = target.previousElementSibling || tabListRef.current.lastChild;\n        break;\n      case nextItemKey:\n        newFocusTarget = target.nextElementSibling || tabListRef.current.firstChild;\n        break;\n      case 'Home':\n        newFocusTarget = tabListRef.current.firstChild;\n        break;\n      case 'End':\n        newFocusTarget = tabListRef.current.lastChild;\n        break;\n      default:\n        break;\n    }\n    if (newFocusTarget !== null) {\n      newFocusTarget.focus();\n      event.preventDefault();\n    }\n  };\n  const conditionalElements = getConditionalElements();\n  return /*#__PURE__*/_jsxs(Component, _extends({\n    className: clsx(classes.root, className, vertical && classes.vertical),\n    ref: ref\n  }, other, {\n    children: [conditionalElements.scrollButtonStart, conditionalElements.scrollbarSizeListener, /*#__PURE__*/_jsxs(\"div\", {\n      className: clsx(classes.scroller, scrollable ? [vertical ? classes.scrollableY : classes.scrollableX, !visibleScrollbar && classes.hideScrollbar] : classes.fixed),\n      style: {\n        overflow: scrollerStyle.overflow,\n        [vertical ? `margin${isRtl ? 'Left' : 'Right'}` : 'marginBottom']: visibleScrollbar ? undefined : -scrollerStyle.scrollbarWidth\n      },\n      ref: tabsRef,\n      onScroll: handleTabsScroll,\n      children: [/*#__PURE__*/_jsx(\"div\", {\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": ariaLabelledBy,\n        \"aria-orientation\": orientation === 'vertical' ? 'vertical' : null,\n        className: clsx(classes.flexContainer, vertical && classes.flexContainerVertical, centered && !scrollable && classes.centered),\n        onKeyDown: handleKeyDown,\n        ref: tabListRef,\n        role: \"tablist\",\n        children: children\n      }), mounted && indicator]\n    }), conditionalElements.scrollButtonEnd]\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? Tabs.propTypes\n/* remove-proptypes */ = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n\n  /**\n   * Callback fired when the component mounts.\n   * This is useful when you want to trigger an action programmatically.\n   * It supports two actions: `updateIndicator()` and `updateScrollButtons()`\n   *\n   * @param {object} actions This object contains all possible actions\n   * that can be triggered programmatically.\n   */\n  action: refType,\n  /**\n   * If `true`, the scroll buttons aren't forced hidden on mobile.\n   * By default the scroll buttons are hidden on mobile and takes precedence over `scrollButtons`.\n   * @default false\n   */\n  allowScrollButtonsMobile: PropTypes.bool,\n  /**\n   * The label for the Tabs as a string.\n   */\n  'aria-label': PropTypes.string,\n  /**\n   * An id or list of ids separated by a space that label the Tabs.\n   */\n  'aria-labelledby': PropTypes.string,\n  /**\n   * If `true`, the tabs are centered.\n   * This prop is intended for large views.\n   * @default false\n   */\n  centered: PropTypes.bool,\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: PropTypes.elementType,\n  /**\n   * Determines the color of the indicator.\n   * @default 'primary'\n   */\n  indicatorColor: PropTypes.oneOf(['primary', 'secondary']),\n  /**\n   * Callback fired when the value changes.\n   *\n   * @param {object} event The event source of the callback. **Warning**: This is a generic event not a change event.\n   * @param {any} value We default to the index of the child (number)\n   */\n  onChange: PropTypes.func,\n  /**\n   * The component orientation (layout flow direction).\n   * @default 'horizontal'\n   */\n  orientation: PropTypes.oneOf(['horizontal', 'vertical']),\n  /**\n   * The component used to render the scroll buttons.\n   * @default TabScrollButton\n   */\n  ScrollButtonComponent: PropTypes.elementType,\n  /**\n   * Determine behavior of scroll buttons when tabs are set to scroll:\n   *\n   * - `auto` will only present them when not all the items are visible.\n   * - `true` will always present them.\n   * - `false` will never present them.\n   *\n   * By default the scroll buttons are hidden on mobile.\n   * This behavior can be disabled with `allowScrollButtonsMobile`.\n   * @default 'auto'\n   */\n  scrollButtons: PropTypes\n  /* @typescript-to-proptypes-ignore */.oneOf(['auto', false, true]),\n  /**\n   * If `true` the selected tab changes on focus. Otherwise it only\n   * changes on activation.\n   */\n  selectionFollowsFocus: PropTypes.bool,\n  /**\n   * Props applied to the tab indicator element.\n   * @default  {}\n   */\n  TabIndicatorProps: PropTypes.object,\n  /**\n   * Props applied to the [`TabScrollButton`](/api/tab-scroll-button/) element.\n   */\n  TabScrollButtonProps: PropTypes.object,\n  /**\n   * Determines the color of the `Tab`.\n   * @default 'primary'\n   */\n  textColor: PropTypes.oneOf(['inherit', 'primary', 'secondary']),\n  /**\n   * The value of the currently selected `Tab`.\n   * If you don't want any selected `Tab`, you can set this prop to `false`.\n   */\n  value: PropTypes.any,\n  /**\n   * Determines additional display behavior of the tabs:\n   *\n   *  - `scrollable` will invoke scrolling properties and allow for horizontally\n   *  scrolling (or swiping) of the tab bar.\n   *  -`fullWidth` will make the tabs grow to use all the available space,\n   *  which should be used for small views, like on mobile.\n   *  - `standard` will render the default state.\n   * @default 'standard'\n   */\n  variant: PropTypes.oneOf(['fullWidth', 'scrollable', 'standard']),\n  /**\n   * If `true`, the scrollbar is visible. It can be useful when displaying\n   * a long vertical list of tabs.\n   * @default false\n   */\n  visibleScrollbar: PropTypes.bool\n} : void 0;\nexport default withStyles(styles, {\n  name: 'MuiTabs'\n})(Tabs);","map":{"version":3,"names":["_extends","_objectWithoutPropertiesLoose","React","isFragment","PropTypes","clsx","refType","debounce","ownerWindow","getNormalizedScrollLeft","detectScrollType","animate","ScrollbarSize","withStyles","TabIndicator","TabScrollButton","useEventCallback","useTheme","jsx","_jsx","jsxs","_jsxs","styles","theme","root","overflow","minHeight","WebkitOverflowScrolling","display","vertical","flexDirection","flexContainer","flexContainerVertical","centered","justifyContent","scroller","position","flex","whiteSpace","fixed","overflowX","width","scrollableX","overflowY","scrollableY","hideScrollbar","scrollbarWidth","scrollButtons","scrollButtonsHideMobile","breakpoints","down","indicator","Tabs","forwardRef","props","ref","ariaLabel","ariaLabelledBy","action","children","childrenProp","classes","className","component","Component","allowScrollButtonsMobile","indicatorColor","onChange","orientation","ScrollButtonComponent","selectionFollowsFocus","TabIndicatorProps","TabScrollButtonProps","textColor","value","variant","visibleScrollbar","other","scrollable","isRtl","direction","scrollStart","start","end","clientSize","size","process","env","NODE_ENV","console","error","mounted","setMounted","useState","indicatorStyle","setIndicatorStyle","displayScroll","setDisplayScroll","scrollerStyle","setScrollerStyle","valueToIndex","Map","tabsRef","useRef","tabListRef","getTabsMeta","tabsNode","current","tabsMeta","rect","getBoundingClientRect","clientWidth","scrollLeft","scrollTop","scrollLeftNormalized","scrollWidth","top","bottom","left","right","tabMeta","length","tab","get","keys","Array","from","join","updateIndicatorState","startValue","correction","newIndicatorStyle","isNaN","dStart","Math","abs","dSize","scroll","scrollValue","moveTabsScroll","delta","getScrollSize","containerSize","totalSize","i","handleStartScrollClick","handleEndScrollClick","handleScrollbarSizeChange","useCallback","getConditionalElements","conditionalElements","scrollbarSizeListener","scrollButtonsActive","showScrollButtons","scrollButtonStart","onClick","disabled","scrollButtonEnd","scrollSelectedIntoView","nextScrollStart","updateScrollButtonState","scrollHeight","clientHeight","showStartScroll","showEndScroll","useEffect","handleResize","win","addEventListener","clear","removeEventListener","handleTabsScroll","useMemo","useImperativeHandle","updateIndicator","updateScrollButtons","color","style","childIndex","Children","map","child","isValidElement","childValue","undefined","set","selected","cloneElement","fullWidth","tabIndex","handleKeyDown","event","target","role","getAttribute","newFocusTarget","previousItemKey","nextItemKey","key","previousElementSibling","lastChild","nextElementSibling","firstChild","focus","preventDefault","onScroll","onKeyDown","propTypes","bool","string","node","object","elementType","oneOf","func","any","name"],"sources":["/Users/shivamrustogi/Documents/GitHub/lab4/node_modules/@material-ui/core/Tabs/Tabs.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport * as React from 'react';\nimport { isFragment } from 'react-is';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { refType } from '@material-ui/utils';\nimport debounce from '../utils/debounce';\nimport ownerWindow from '../utils/ownerWindow';\nimport { getNormalizedScrollLeft, detectScrollType } from '../utils/scrollLeft';\nimport animate from '../internal/animate';\nimport ScrollbarSize from './ScrollbarSize';\nimport withStyles from '../styles/withStyles';\nimport TabIndicator from './TabIndicator';\nimport TabScrollButton from '../TabScrollButton';\nimport useEventCallback from '../utils/useEventCallback';\nimport useTheme from '../styles/useTheme';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nexport const styles = theme => ({\n  /* Styles applied to the root element. */\n  root: {\n    overflow: 'hidden',\n    minHeight: 48,\n    WebkitOverflowScrolling: 'touch',\n    // Add iOS momentum scrolling.\n    display: 'flex'\n  },\n\n  /* Styles applied to the root element if `orientation=\"vertical\"`. */\n  vertical: {\n    flexDirection: 'column'\n  },\n\n  /* Styles applied to the flex container element. */\n  flexContainer: {\n    display: 'flex'\n  },\n\n  /* Styles applied to the flex container element if `orientation=\"vertical\"`. */\n  flexContainerVertical: {\n    flexDirection: 'column'\n  },\n\n  /* Styles applied to the flex container element if `centered={true}` & `!variant=\"scrollable\"`. */\n  centered: {\n    justifyContent: 'center'\n  },\n\n  /* Styles applied to the tablist element. */\n  scroller: {\n    position: 'relative',\n    display: 'inline-block',\n    flex: '1 1 auto',\n    whiteSpace: 'nowrap'\n  },\n\n  /* Styles applied to the tablist element if `!variant=\"scrollable\"`\b\b\b. */\n  fixed: {\n    overflowX: 'hidden',\n    width: '100%'\n  },\n\n  /* Styles applied to the tablist element if `variant=\"scrollable\"` and `orientation=\"horizontal\"`. */\n  scrollableX: {\n    overflowX: 'auto',\n    overflowY: 'hidden'\n  },\n\n  /* Styles applied to the tablist element if `variant=\"scrollable\"` and `orientation=\"vertical\"`. */\n  scrollableY: {\n    overflowY: 'auto',\n    overflowX: 'hidden'\n  },\n\n  /* Styles applied to the tablist element if `variant=\"scrollable\"` and `visibleScrollbar={false}`. */\n  hideScrollbar: {\n    // Hide dimensionless scrollbar on MacOS\n    scrollbarWidth: 'none',\n    // Firefox\n    '&::-webkit-scrollbar': {\n      display: 'none' // Safari + Chrome\n\n    }\n  },\n\n  /* Styles applied to the ScrollButtonComponent component. */\n  scrollButtons: {},\n\n  /* Styles applied to the ScrollButtonComponent component if `allowScrollButtonsMobile={true}`. */\n  scrollButtonsHideMobile: {\n    [theme.breakpoints.down('sm')]: {\n      display: 'none'\n    }\n  },\n\n  /* Styles applied to the TabIndicator component. */\n  indicator: {}\n});\nconst Tabs = /*#__PURE__*/React.forwardRef(function Tabs(props, ref) {\n  const {\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledBy,\n    action,\n    centered = false,\n    children: childrenProp,\n    classes,\n    className,\n    component: Component = 'div',\n    allowScrollButtonsMobile = false,\n    indicatorColor = 'primary',\n    onChange,\n    orientation = 'horizontal',\n    ScrollButtonComponent = TabScrollButton,\n    scrollButtons = 'auto',\n    selectionFollowsFocus,\n    TabIndicatorProps = {},\n    TabScrollButtonProps,\n    textColor = 'primary',\n    value,\n    variant = 'standard',\n    visibleScrollbar = false\n  } = props,\n        other = _objectWithoutPropertiesLoose(props, [\"aria-label\", \"aria-labelledby\", \"action\", \"centered\", \"children\", \"classes\", \"className\", \"component\", \"allowScrollButtonsMobile\", \"indicatorColor\", \"onChange\", \"orientation\", \"ScrollButtonComponent\", \"scrollButtons\", \"selectionFollowsFocus\", \"TabIndicatorProps\", \"TabScrollButtonProps\", \"textColor\", \"value\", \"variant\", \"visibleScrollbar\"]);\n\n  const theme = useTheme();\n  const scrollable = variant === 'scrollable';\n  const isRtl = theme.direction === 'rtl';\n  const vertical = orientation === 'vertical';\n  const scrollStart = vertical ? 'scrollTop' : 'scrollLeft';\n  const start = vertical ? 'top' : 'left';\n  const end = vertical ? 'bottom' : 'right';\n  const clientSize = vertical ? 'clientHeight' : 'clientWidth';\n  const size = vertical ? 'height' : 'width';\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (centered && scrollable) {\n      console.error('Material-UI: You can not use the `centered={true}` and `variant=\"scrollable\"` properties ' + 'at the same time on a `Tabs` component.');\n    }\n  }\n\n  const [mounted, setMounted] = React.useState(false);\n  const [indicatorStyle, setIndicatorStyle] = React.useState({});\n  const [displayScroll, setDisplayScroll] = React.useState({\n    start: false,\n    end: false\n  });\n  const [scrollerStyle, setScrollerStyle] = React.useState({\n    overflow: 'hidden',\n    scrollbarWidth: 0\n  });\n  const valueToIndex = new Map();\n  const tabsRef = React.useRef(null);\n  const tabListRef = React.useRef(null);\n\n  const getTabsMeta = () => {\n    const tabsNode = tabsRef.current;\n    let tabsMeta;\n\n    if (tabsNode) {\n      const rect = tabsNode.getBoundingClientRect(); // create a new object with ClientRect class props + scrollLeft\n\n      tabsMeta = {\n        clientWidth: tabsNode.clientWidth,\n        scrollLeft: tabsNode.scrollLeft,\n        scrollTop: tabsNode.scrollTop,\n        scrollLeftNormalized: getNormalizedScrollLeft(tabsNode, theme.direction),\n        scrollWidth: tabsNode.scrollWidth,\n        top: rect.top,\n        bottom: rect.bottom,\n        left: rect.left,\n        right: rect.right\n      };\n    }\n\n    let tabMeta;\n\n    if (tabsNode && value !== false) {\n      const children = tabListRef.current.children;\n\n      if (children.length > 0) {\n        const tab = children[valueToIndex.get(value)];\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (!tab) {\n            console.error([`Material-UI: The value provided to the Tabs component is invalid.`, `None of the Tabs' children match with \\`${value}\\`.`, valueToIndex.keys ? `You can provide one of the following values: ${Array.from(valueToIndex.keys()).join(', ')}.` : null].join('\\n'));\n          }\n        }\n\n        tabMeta = tab ? tab.getBoundingClientRect() : null;\n      }\n    }\n\n    return {\n      tabsMeta,\n      tabMeta\n    };\n  };\n\n  const updateIndicatorState = useEventCallback(() => {\n    const {\n      tabsMeta,\n      tabMeta\n    } = getTabsMeta();\n    let startValue = 0;\n\n    if (tabMeta && tabsMeta) {\n      if (vertical) {\n        startValue = tabMeta.top - tabsMeta.top + tabsMeta.scrollTop;\n      } else {\n        const correction = isRtl ? tabsMeta.scrollLeftNormalized + tabsMeta.clientWidth - tabsMeta.scrollWidth : tabsMeta.scrollLeft;\n        startValue = tabMeta.left - tabsMeta.left + correction;\n      }\n    }\n\n    const newIndicatorStyle = {\n      [start]: startValue,\n      // May be wrong until the font is loaded.\n      [size]: tabMeta ? tabMeta[size] : 0\n    }; // IE11 support, replace with Number.isNaN\n    // eslint-disable-next-line no-restricted-globals\n\n    if (isNaN(indicatorStyle[start]) || isNaN(indicatorStyle[size])) {\n      setIndicatorStyle(newIndicatorStyle);\n    } else {\n      const dStart = Math.abs(indicatorStyle[start] - newIndicatorStyle[start]);\n      const dSize = Math.abs(indicatorStyle[size] - newIndicatorStyle[size]);\n\n      if (dStart >= 1 || dSize >= 1) {\n        setIndicatorStyle(newIndicatorStyle);\n      }\n    }\n  });\n\n  const scroll = scrollValue => {\n    animate(scrollStart, tabsRef.current, scrollValue);\n  };\n\n  const moveTabsScroll = delta => {\n    let scrollValue = tabsRef.current[scrollStart];\n\n    if (vertical) {\n      scrollValue += delta;\n    } else {\n      scrollValue += delta * (isRtl ? -1 : 1); // Fix for Edge\n\n      scrollValue *= isRtl && detectScrollType() === 'reverse' ? -1 : 1;\n    }\n\n    scroll(scrollValue);\n  };\n\n  const getScrollSize = () => {\n    const containerSize = tabsRef.current[clientSize];\n    let totalSize = 0;\n    const children = Array.from(tabListRef.current.children);\n\n    for (let i = 0; i < children.length; i += 1) {\n      const tab = children[i];\n\n      if (totalSize + tab[clientSize] > containerSize) {\n        break;\n      }\n\n      totalSize += tab[clientSize];\n    }\n\n    return totalSize;\n  };\n\n  const handleStartScrollClick = () => {\n    moveTabsScroll(-1 * getScrollSize());\n  };\n\n  const handleEndScrollClick = () => {\n    moveTabsScroll(getScrollSize());\n  }; // TODO Remove <ScrollbarSize /> as browser support for hidding the scrollbar\n  // with CSS improves.\n\n\n  const handleScrollbarSizeChange = React.useCallback(scrollbarWidth => {\n    setScrollerStyle({\n      overflow: null,\n      scrollbarWidth\n    });\n  }, []);\n\n  const getConditionalElements = () => {\n    const conditionalElements = {};\n    conditionalElements.scrollbarSizeListener = scrollable ? /*#__PURE__*/_jsx(ScrollbarSize, {\n      onChange: handleScrollbarSizeChange,\n      className: clsx(classes.scrollableX, classes.hideScrollbar)\n    }) : null;\n    const scrollButtonsActive = displayScroll.start || displayScroll.end;\n    const showScrollButtons = scrollable && (scrollButtons === 'auto' && scrollButtonsActive || scrollButtons === true);\n    conditionalElements.scrollButtonStart = showScrollButtons ? /*#__PURE__*/_jsx(ScrollButtonComponent, _extends({\n      orientation: orientation,\n      direction: isRtl ? 'right' : 'left',\n      onClick: handleStartScrollClick,\n      disabled: !displayScroll.start,\n      className: clsx(classes.scrollButtons, !allowScrollButtonsMobile && classes.scrollButtonsHideMobile)\n    }, TabScrollButtonProps)) : null;\n    conditionalElements.scrollButtonEnd = showScrollButtons ? /*#__PURE__*/_jsx(ScrollButtonComponent, _extends({\n      orientation: orientation,\n      direction: isRtl ? 'left' : 'right',\n      onClick: handleEndScrollClick,\n      disabled: !displayScroll.end,\n      className: clsx(classes.scrollButtons, !allowScrollButtonsMobile && classes.scrollButtonsHideMobile)\n    }, TabScrollButtonProps)) : null;\n    return conditionalElements;\n  };\n\n  const scrollSelectedIntoView = useEventCallback(() => {\n    const {\n      tabsMeta,\n      tabMeta\n    } = getTabsMeta();\n\n    if (!tabMeta || !tabsMeta) {\n      return;\n    }\n\n    if (tabMeta[start] < tabsMeta[start]) {\n      // left side of button is out of view\n      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[start] - tabsMeta[start]);\n      scroll(nextScrollStart);\n    } else if (tabMeta[end] > tabsMeta[end]) {\n      // right side of button is out of view\n      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[end] - tabsMeta[end]);\n      scroll(nextScrollStart);\n    }\n  });\n  const updateScrollButtonState = useEventCallback(() => {\n    if (scrollable && scrollButtons !== false) {\n      const {\n        scrollTop,\n        scrollHeight,\n        clientHeight,\n        scrollWidth,\n        clientWidth\n      } = tabsRef.current;\n      let showStartScroll;\n      let showEndScroll;\n\n      if (vertical) {\n        showStartScroll = scrollTop > 1;\n        showEndScroll = scrollTop < scrollHeight - clientHeight - 1;\n      } else {\n        const scrollLeft = getNormalizedScrollLeft(tabsRef.current, theme.direction); // use 1 for the potential rounding error with browser zooms.\n\n        showStartScroll = isRtl ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;\n        showEndScroll = !isRtl ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;\n      }\n\n      if (showStartScroll !== displayScroll.start || showEndScroll !== displayScroll.end) {\n        setDisplayScroll({\n          start: showStartScroll,\n          end: showEndScroll\n        });\n      }\n    }\n  });\n  React.useEffect(() => {\n    const handleResize = debounce(() => {\n      updateIndicatorState();\n      updateScrollButtonState();\n    });\n    const win = ownerWindow(tabsRef.current);\n    win.addEventListener('resize', handleResize);\n    return () => {\n      handleResize.clear();\n      win.removeEventListener('resize', handleResize);\n    };\n  }, [updateIndicatorState, updateScrollButtonState]);\n  const handleTabsScroll = React.useMemo(() => debounce(() => {\n    updateScrollButtonState();\n  }), [updateScrollButtonState]);\n  React.useEffect(() => {\n    return () => {\n      handleTabsScroll.clear();\n    };\n  }, [handleTabsScroll]);\n  React.useEffect(() => {\n    setMounted(true);\n  }, []);\n  React.useEffect(() => {\n    updateIndicatorState();\n    updateScrollButtonState();\n  });\n  React.useEffect(() => {\n    scrollSelectedIntoView();\n  }, [scrollSelectedIntoView, indicatorStyle]);\n  React.useImperativeHandle(action, () => ({\n    updateIndicator: updateIndicatorState,\n    updateScrollButtons: updateScrollButtonState\n  }), [updateIndicatorState, updateScrollButtonState]);\n\n  const indicator = /*#__PURE__*/_jsx(TabIndicator, _extends({\n    className: classes.indicator,\n    orientation: orientation,\n    color: indicatorColor\n  }, TabIndicatorProps, {\n    style: _extends({}, indicatorStyle, TabIndicatorProps.style)\n  }));\n\n  let childIndex = 0;\n  const children = React.Children.map(childrenProp, child => {\n    if (! /*#__PURE__*/React.isValidElement(child)) {\n      return null;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (isFragment(child)) {\n        console.error([\"Material-UI: The Tabs component doesn't accept a Fragment as a child.\", 'Consider providing an array instead.'].join('\\n'));\n      }\n    }\n\n    const childValue = child.props.value === undefined ? childIndex : child.props.value;\n    valueToIndex.set(childValue, childIndex);\n    const selected = childValue === value;\n    childIndex += 1;\n    return /*#__PURE__*/React.cloneElement(child, _extends({\n      fullWidth: variant === 'fullWidth',\n      indicator: selected && !mounted && indicator,\n      selected,\n      selectionFollowsFocus,\n      onChange,\n      textColor,\n      value: childValue\n    }, childIndex === 1 && value === false && !child.props.tabIndex ? {\n      tabIndex: 0\n    } : {}));\n  });\n\n  const handleKeyDown = event => {\n    const {\n      target\n    } = event; // Keyboard navigation assumes that [role=\"tab\"] are siblings\n    // though we might warn in the future about nested, interactive elements\n    // as a a11y violation\n\n    const role = target.getAttribute('role');\n\n    if (role !== 'tab') {\n      return;\n    }\n\n    let newFocusTarget = null;\n    let previousItemKey = orientation !== \"vertical\" ? 'ArrowLeft' : 'ArrowUp';\n    let nextItemKey = orientation !== \"vertical\" ? 'ArrowRight' : 'ArrowDown';\n\n    if (orientation !== \"vertical\" && theme.direction === 'rtl') {\n      // swap previousItemKey with nextItemKey\n      previousItemKey = 'ArrowRight';\n      nextItemKey = 'ArrowLeft';\n    }\n\n    switch (event.key) {\n      case previousItemKey:\n        newFocusTarget = target.previousElementSibling || tabListRef.current.lastChild;\n        break;\n\n      case nextItemKey:\n        newFocusTarget = target.nextElementSibling || tabListRef.current.firstChild;\n        break;\n\n      case 'Home':\n        newFocusTarget = tabListRef.current.firstChild;\n        break;\n\n      case 'End':\n        newFocusTarget = tabListRef.current.lastChild;\n        break;\n\n      default:\n        break;\n    }\n\n    if (newFocusTarget !== null) {\n      newFocusTarget.focus();\n      event.preventDefault();\n    }\n  };\n\n  const conditionalElements = getConditionalElements();\n  return /*#__PURE__*/_jsxs(Component, _extends({\n    className: clsx(classes.root, className, vertical && classes.vertical),\n    ref: ref\n  }, other, {\n    children: [conditionalElements.scrollButtonStart, conditionalElements.scrollbarSizeListener, /*#__PURE__*/_jsxs(\"div\", {\n      className: clsx(classes.scroller, scrollable ? [vertical ? classes.scrollableY : classes.scrollableX, !visibleScrollbar && classes.hideScrollbar] : classes.fixed),\n      style: {\n        overflow: scrollerStyle.overflow,\n        [vertical ? `margin${isRtl ? 'Left' : 'Right'}` : 'marginBottom']: visibleScrollbar ? undefined : -scrollerStyle.scrollbarWidth\n      },\n      ref: tabsRef,\n      onScroll: handleTabsScroll,\n      children: [/*#__PURE__*/_jsx(\"div\", {\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": ariaLabelledBy,\n        \"aria-orientation\": orientation === 'vertical' ? 'vertical' : null,\n        className: clsx(classes.flexContainer, vertical && classes.flexContainerVertical, centered && !scrollable && classes.centered),\n        onKeyDown: handleKeyDown,\n        ref: tabListRef,\n        role: \"tablist\",\n        children: children\n      }), mounted && indicator]\n    }), conditionalElements.scrollButtonEnd]\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? Tabs.propTypes\n/* remove-proptypes */\n= {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n\n  /**\n   * Callback fired when the component mounts.\n   * This is useful when you want to trigger an action programmatically.\n   * It supports two actions: `updateIndicator()` and `updateScrollButtons()`\n   *\n   * @param {object} actions This object contains all possible actions\n   * that can be triggered programmatically.\n   */\n  action: refType,\n\n  /**\n   * If `true`, the scroll buttons aren't forced hidden on mobile.\n   * By default the scroll buttons are hidden on mobile and takes precedence over `scrollButtons`.\n   * @default false\n   */\n  allowScrollButtonsMobile: PropTypes.bool,\n\n  /**\n   * The label for the Tabs as a string.\n   */\n  'aria-label': PropTypes.string,\n\n  /**\n   * An id or list of ids separated by a space that label the Tabs.\n   */\n  'aria-labelledby': PropTypes.string,\n\n  /**\n   * If `true`, the tabs are centered.\n   * This prop is intended for large views.\n   * @default false\n   */\n  centered: PropTypes.bool,\n\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: PropTypes.elementType,\n\n  /**\n   * Determines the color of the indicator.\n   * @default 'primary'\n   */\n  indicatorColor: PropTypes.oneOf(['primary', 'secondary']),\n\n  /**\n   * Callback fired when the value changes.\n   *\n   * @param {object} event The event source of the callback. **Warning**: This is a generic event not a change event.\n   * @param {any} value We default to the index of the child (number)\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * The component orientation (layout flow direction).\n   * @default 'horizontal'\n   */\n  orientation: PropTypes.oneOf(['horizontal', 'vertical']),\n\n  /**\n   * The component used to render the scroll buttons.\n   * @default TabScrollButton\n   */\n  ScrollButtonComponent: PropTypes.elementType,\n\n  /**\n   * Determine behavior of scroll buttons when tabs are set to scroll:\n   *\n   * - `auto` will only present them when not all the items are visible.\n   * - `true` will always present them.\n   * - `false` will never present them.\n   *\n   * By default the scroll buttons are hidden on mobile.\n   * This behavior can be disabled with `allowScrollButtonsMobile`.\n   * @default 'auto'\n   */\n  scrollButtons: PropTypes\n  /* @typescript-to-proptypes-ignore */\n  .oneOf(['auto', false, true]),\n\n  /**\n   * If `true` the selected tab changes on focus. Otherwise it only\n   * changes on activation.\n   */\n  selectionFollowsFocus: PropTypes.bool,\n\n  /**\n   * Props applied to the tab indicator element.\n   * @default  {}\n   */\n  TabIndicatorProps: PropTypes.object,\n\n  /**\n   * Props applied to the [`TabScrollButton`](/api/tab-scroll-button/) element.\n   */\n  TabScrollButtonProps: PropTypes.object,\n\n  /**\n   * Determines the color of the `Tab`.\n   * @default 'primary'\n   */\n  textColor: PropTypes.oneOf(['inherit', 'primary', 'secondary']),\n\n  /**\n   * The value of the currently selected `Tab`.\n   * If you don't want any selected `Tab`, you can set this prop to `false`.\n   */\n  value: PropTypes.any,\n\n  /**\n   * Determines additional display behavior of the tabs:\n   *\n   *  - `scrollable` will invoke scrolling properties and allow for horizontally\n   *  scrolling (or swiping) of the tab bar.\n   *  -`fullWidth` will make the tabs grow to use all the available space,\n   *  which should be used for small views, like on mobile.\n   *  - `standard` will render the default state.\n   * @default 'standard'\n   */\n  variant: PropTypes.oneOf(['fullWidth', 'scrollable', 'standard']),\n\n  /**\n   * If `true`, the scrollbar is visible. It can be useful when displaying\n   * a long vertical list of tabs.\n   * @default false\n   */\n  visibleScrollbar: PropTypes.bool\n} : void 0;\nexport default withStyles(styles, {\n  name: 'MuiTabs'\n})(Tabs);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
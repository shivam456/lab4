{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst smart_1 = require(\"../smart\");\nconst Client_1 = require(\"../Client\");\nconst BrowserStorage_1 = require(\"../storage/BrowserStorage\");\nconst security = require(\"../security/browser\");\nconst js_base64_1 = require(\"js-base64\");\n/**\n * Browser Adapter\n */\n\nclass BrowserAdapter {\n  /**\n   * @param options Environment-specific options\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    /**\n     * Stores the URL instance associated with this adapter\n     */\n    this._url = null;\n    /**\n     * Holds the Storage instance associated with this instance\n     */\n\n    this._storage = null;\n    this.security = security;\n    this.options = Object.assign({\n      // Replaces the browser's current URL\n      // using window.history.replaceState API or by reloading.\n      replaceBrowserHistory: true,\n      // When set to true, this variable will fully utilize\n      // HTML5 sessionStorage API.\n      // This variable can be overridden to false by setting\n      // FHIR.oauth2.settings.fullSessionStorageSupport = false.\n      // When set to false, the sessionStorage will be keyed\n      // by a state variable. This is to allow the embedded IE browser\n      // instances instantiated on a single thread to continue to\n      // function without having sessionStorage data shared\n      // across the embedded IE instances.\n      fullSessionStorageSupport: true,\n      // Do we want to send cookies while making a request to the token\n      // endpoint in order to obtain new access token using existing\n      // refresh token. In rare cases the auth server might require the\n      // client to send cookies along with those requests. In this case\n      // developers will have to change this before initializing the app\n      // like so:\n      // `FHIR.oauth2.settings.refreshTokenWithCredentials = \"include\";`\n      // or\n      // `FHIR.oauth2.settings.refreshTokenWithCredentials = \"same-origin\";`\n      // Can be one of:\n      // \"include\"     - always send cookies\n      // \"same-origin\" - only send cookies if we are on the same domain (default)\n      // \"omit\"        - do not send cookies\n      refreshTokenWithCredentials: \"same-origin\"\n    }, options);\n  }\n  /**\n   * Given a relative path, returns an absolute url using the instance base URL\n   */\n\n  relative(path) {\n    return new URL(path, this.getUrl().href).href;\n  }\n  /**\n   * In browsers we need to be able to (dynamically) check if fhir.js is\n   * included in the page. If it is, it should have created a \"fhir\" variable\n   * in the global scope.\n   */\n\n  get fhir() {\n    // @ts-ignore\n    return typeof fhir === \"function\" ? fhir : null;\n  }\n  /**\n   * Given the current environment, this method must return the current url\n   * as URL instance\n   */\n\n  getUrl() {\n    if (!this._url) {\n      this._url = new URL(location + \"\");\n    }\n    return this._url;\n  }\n  /**\n   * Given the current environment, this method must redirect to the given\n   * path\n   */\n\n  redirect(to) {\n    location.href = to;\n  }\n  /**\n   * Returns a BrowserStorage object which is just a wrapper around\n   * sessionStorage\n   */\n\n  getStorage() {\n    if (!this._storage) {\n      this._storage = new BrowserStorage_1.default();\n    }\n    return this._storage;\n  }\n  /**\n   * Returns a reference to the AbortController constructor. In browsers,\n   * AbortController will always be available as global (native or polyfilled)\n   */\n\n  getAbortController() {\n    return AbortController;\n  }\n  /**\n   * ASCII string to Base64\n   */\n\n  atob(str) {\n    return window.atob(str);\n  }\n  /**\n   * Base64 to ASCII string\n   */\n\n  btoa(str) {\n    return window.btoa(str);\n  }\n  base64urlencode(input) {\n    if (typeof input == \"string\") {\n      return (0, js_base64_1.encodeURL)(input);\n    }\n    return (0, js_base64_1.fromUint8Array)(input, true);\n  }\n  base64urldecode(input) {\n    return (0, js_base64_1.decode)(input);\n  }\n  /**\n   * Creates and returns adapter-aware SMART api. Not that while the shape of\n   * the returned object is well known, the arguments to this function are not.\n   * Those who override this method are free to require any environment-specific\n   * arguments. For example in node we will need a request, a response and\n   * optionally a storage or storage factory function.\n   */\n\n  getSmartApi() {\n    var _this = this;\n    return {\n      ready: function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        return (0, smart_1.ready)(_this, ...args);\n      },\n      authorize: options => (0, smart_1.authorize)(this, options),\n      init: options => (0, smart_1.init)(this, options),\n      client: state => new Client_1.default(this, state),\n      options: this.options,\n      utils: {\n        security\n      }\n    };\n  }\n}\nexports.default = BrowserAdapter;","map":{"version":3,"names":["Object","defineProperty","exports","value","smart_1","require","Client_1","BrowserStorage_1","security","js_base64_1","BrowserAdapter","constructor","options","_url","_storage","assign","replaceBrowserHistory","fullSessionStorageSupport","refreshTokenWithCredentials","relative","path","URL","getUrl","href","fhir","location","redirect","to","getStorage","default","getAbortController","AbortController","atob","str","window","btoa","base64urlencode","input","encodeURL","fromUint8Array","base64urldecode","decode","getSmartApi","ready","args","authorize","init","client","state","utils"],"sources":["/Users/shivamrustogi/Documents/GitHub/lab4/node_modules/fhirclient/lib/adapters/BrowserAdapter.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst smart_1 = require(\"../smart\");\n\nconst Client_1 = require(\"../Client\");\n\nconst BrowserStorage_1 = require(\"../storage/BrowserStorage\");\n\nconst security = require(\"../security/browser\");\n\nconst js_base64_1 = require(\"js-base64\");\n/**\n * Browser Adapter\n */\n\n\nclass BrowserAdapter {\n  /**\n   * @param options Environment-specific options\n   */\n  constructor(options = {}) {\n    /**\n     * Stores the URL instance associated with this adapter\n     */\n    this._url = null;\n    /**\n     * Holds the Storage instance associated with this instance\n     */\n\n    this._storage = null;\n    this.security = security;\n    this.options = Object.assign({\n      // Replaces the browser's current URL\n      // using window.history.replaceState API or by reloading.\n      replaceBrowserHistory: true,\n      // When set to true, this variable will fully utilize\n      // HTML5 sessionStorage API.\n      // This variable can be overridden to false by setting\n      // FHIR.oauth2.settings.fullSessionStorageSupport = false.\n      // When set to false, the sessionStorage will be keyed\n      // by a state variable. This is to allow the embedded IE browser\n      // instances instantiated on a single thread to continue to\n      // function without having sessionStorage data shared\n      // across the embedded IE instances.\n      fullSessionStorageSupport: true,\n      // Do we want to send cookies while making a request to the token\n      // endpoint in order to obtain new access token using existing\n      // refresh token. In rare cases the auth server might require the\n      // client to send cookies along with those requests. In this case\n      // developers will have to change this before initializing the app\n      // like so:\n      // `FHIR.oauth2.settings.refreshTokenWithCredentials = \"include\";`\n      // or\n      // `FHIR.oauth2.settings.refreshTokenWithCredentials = \"same-origin\";`\n      // Can be one of:\n      // \"include\"     - always send cookies\n      // \"same-origin\" - only send cookies if we are on the same domain (default)\n      // \"omit\"        - do not send cookies\n      refreshTokenWithCredentials: \"same-origin\"\n    }, options);\n  }\n  /**\n   * Given a relative path, returns an absolute url using the instance base URL\n   */\n\n\n  relative(path) {\n    return new URL(path, this.getUrl().href).href;\n  }\n  /**\n   * In browsers we need to be able to (dynamically) check if fhir.js is\n   * included in the page. If it is, it should have created a \"fhir\" variable\n   * in the global scope.\n   */\n\n\n  get fhir() {\n    // @ts-ignore\n    return typeof fhir === \"function\" ? fhir : null;\n  }\n  /**\n   * Given the current environment, this method must return the current url\n   * as URL instance\n   */\n\n\n  getUrl() {\n    if (!this._url) {\n      this._url = new URL(location + \"\");\n    }\n\n    return this._url;\n  }\n  /**\n   * Given the current environment, this method must redirect to the given\n   * path\n   */\n\n\n  redirect(to) {\n    location.href = to;\n  }\n  /**\n   * Returns a BrowserStorage object which is just a wrapper around\n   * sessionStorage\n   */\n\n\n  getStorage() {\n    if (!this._storage) {\n      this._storage = new BrowserStorage_1.default();\n    }\n\n    return this._storage;\n  }\n  /**\n   * Returns a reference to the AbortController constructor. In browsers,\n   * AbortController will always be available as global (native or polyfilled)\n   */\n\n\n  getAbortController() {\n    return AbortController;\n  }\n  /**\n   * ASCII string to Base64\n   */\n\n\n  atob(str) {\n    return window.atob(str);\n  }\n  /**\n   * Base64 to ASCII string\n   */\n\n\n  btoa(str) {\n    return window.btoa(str);\n  }\n\n  base64urlencode(input) {\n    if (typeof input == \"string\") {\n      return (0, js_base64_1.encodeURL)(input);\n    }\n\n    return (0, js_base64_1.fromUint8Array)(input, true);\n  }\n\n  base64urldecode(input) {\n    return (0, js_base64_1.decode)(input);\n  }\n  /**\n   * Creates and returns adapter-aware SMART api. Not that while the shape of\n   * the returned object is well known, the arguments to this function are not.\n   * Those who override this method are free to require any environment-specific\n   * arguments. For example in node we will need a request, a response and\n   * optionally a storage or storage factory function.\n   */\n\n\n  getSmartApi() {\n    return {\n      ready: (...args) => (0, smart_1.ready)(this, ...args),\n      authorize: options => (0, smart_1.authorize)(this, options),\n      init: options => (0, smart_1.init)(this, options),\n      client: state => new Client_1.default(this, state),\n      options: this.options,\n      utils: {\n        security\n      }\n    };\n  }\n\n}\n\nexports.default = BrowserAdapter;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
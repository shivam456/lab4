{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst smart_1 = require(\"../smart\");\n\nconst Client_1 = require(\"../Client\");\n\nconst BrowserStorage_1 = require(\"../storage/BrowserStorage\");\n/**\n * Browser Adapter\n */\n\n\nclass BrowserAdapter {\n  /**\n   * @param options Environment-specific options\n   */\n  constructor(options = {}) {\n    /**\n     * Stores the URL instance associated with this adapter\n     */\n    this._url = null;\n    /**\n     * Holds the Storage instance associated with this instance\n     */\n\n    this._storage = null;\n    this.options = Object.assign({\n      // Replaces the browser's current URL\n      // using window.history.replaceState API or by reloading.\n      replaceBrowserHistory: true,\n      // When set to true, this variable will fully utilize\n      // HTML5 sessionStorage API.\n      // This variable can be overridden to false by setting\n      // FHIR.oauth2.settings.fullSessionStorageSupport = false.\n      // When set to false, the sessionStorage will be keyed\n      // by a state variable. This is to allow the embedded IE browser\n      // instances instantiated on a single thread to continue to\n      // function without having sessionStorage data shared\n      // across the embedded IE instances.\n      fullSessionStorageSupport: true,\n      // Do we want to send cookies while making a request to the token\n      // endpoint in order to obtain new access token using existing\n      // refresh token. In rare cases the auth server might require the\n      // client to send cookies along with those requests. In this case\n      // developers will have to change this before initializing the app\n      // like so:\n      // `FHIR.oauth2.settings.refreshTokenWithCredentials = \"include\";`\n      // or\n      // `FHIR.oauth2.settings.refreshTokenWithCredentials = \"same-origin\";`\n      // Can be one of:\n      // \"include\"     - always send cookies\n      // \"same-origin\" - only send cookies if we are on the same domain (default)\n      // \"omit\"        - do not send cookies\n      refreshTokenWithCredentials: \"same-origin\"\n    }, options);\n  }\n  /**\n   * Given a relative path, returns an absolute url using the instance base URL\n   */\n\n\n  relative(path) {\n    return new URL(path, this.getUrl().href).href;\n  }\n  /**\n   * In browsers we need to be able to (dynamically) check if fhir.js is\n   * included in the page. If it is, it should have created a \"fhir\" variable\n   * in the global scope.\n   */\n\n\n  get fhir() {\n    // @ts-ignore\n    return typeof fhir === \"function\" ? fhir : null;\n  }\n  /**\n   * Given the current environment, this method must return the current url\n   * as URL instance\n   */\n\n\n  getUrl() {\n    if (!this._url) {\n      this._url = new URL(location + \"\");\n    }\n\n    return this._url;\n  }\n  /**\n   * Given the current environment, this method must redirect to the given\n   * path\n   */\n\n\n  redirect(to) {\n    location.href = to;\n  }\n  /**\n   * Returns a BrowserStorage object which is just a wrapper around\n   * sessionStorage\n   */\n\n\n  getStorage() {\n    if (!this._storage) {\n      this._storage = new BrowserStorage_1.default();\n    }\n\n    return this._storage;\n  }\n  /**\n   * Returns a reference to the AbortController constructor. In browsers,\n   * AbortController will always be available as global (native or polyfilled)\n   */\n\n\n  getAbortController() {\n    return AbortController;\n  }\n  /**\n   * ASCII string to Base64\n   */\n\n\n  atob(str) {\n    return window.atob(str);\n  }\n  /**\n   * Base64 to ASCII string\n   */\n\n\n  btoa(str) {\n    return window.btoa(str);\n  }\n  /**\n   * Creates and returns adapter-aware SMART api. Not that while the shape of\n   * the returned object is well known, the arguments to this function are not.\n   * Those who override this method are free to require any environment-specific\n   * arguments. For example in node we will need a request, a response and\n   * optionally a storage or storage factory function.\n   */\n\n\n  getSmartApi() {\n    return {\n      ready: (...args) => smart_1.ready(this, ...args),\n      authorize: options => smart_1.authorize(this, options),\n      init: options => smart_1.init(this, options),\n      client: state => new Client_1.default(this, state),\n      options: this.options\n    };\n  }\n\n}\n\nexports.default = BrowserAdapter;","map":{"version":3,"sources":["/Users/rajvansia/Documents/GitHub/lab-4-react-workingcopy/node_modules/fhirclient/lib/adapters/BrowserAdapter.js"],"names":["Object","defineProperty","exports","value","smart_1","require","Client_1","BrowserStorage_1","BrowserAdapter","constructor","options","_url","_storage","assign","replaceBrowserHistory","fullSessionStorageSupport","refreshTokenWithCredentials","relative","path","URL","getUrl","href","fhir","location","redirect","to","getStorage","default","getAbortController","AbortController","atob","str","window","btoa","getSmartApi","ready","args","authorize","init","client","state"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst smart_1 = require(\"../smart\");\n\nconst Client_1 = require(\"../Client\");\n\nconst BrowserStorage_1 = require(\"../storage/BrowserStorage\");\n/**\n * Browser Adapter\n */\n\n\nclass BrowserAdapter {\n  /**\n   * @param options Environment-specific options\n   */\n  constructor(options = {}) {\n    /**\n     * Stores the URL instance associated with this adapter\n     */\n    this._url = null;\n    /**\n     * Holds the Storage instance associated with this instance\n     */\n\n    this._storage = null;\n    this.options = Object.assign({\n      // Replaces the browser's current URL\n      // using window.history.replaceState API or by reloading.\n      replaceBrowserHistory: true,\n      // When set to true, this variable will fully utilize\n      // HTML5 sessionStorage API.\n      // This variable can be overridden to false by setting\n      // FHIR.oauth2.settings.fullSessionStorageSupport = false.\n      // When set to false, the sessionStorage will be keyed\n      // by a state variable. This is to allow the embedded IE browser\n      // instances instantiated on a single thread to continue to\n      // function without having sessionStorage data shared\n      // across the embedded IE instances.\n      fullSessionStorageSupport: true,\n      // Do we want to send cookies while making a request to the token\n      // endpoint in order to obtain new access token using existing\n      // refresh token. In rare cases the auth server might require the\n      // client to send cookies along with those requests. In this case\n      // developers will have to change this before initializing the app\n      // like so:\n      // `FHIR.oauth2.settings.refreshTokenWithCredentials = \"include\";`\n      // or\n      // `FHIR.oauth2.settings.refreshTokenWithCredentials = \"same-origin\";`\n      // Can be one of:\n      // \"include\"     - always send cookies\n      // \"same-origin\" - only send cookies if we are on the same domain (default)\n      // \"omit\"        - do not send cookies\n      refreshTokenWithCredentials: \"same-origin\"\n    }, options);\n  }\n  /**\n   * Given a relative path, returns an absolute url using the instance base URL\n   */\n\n\n  relative(path) {\n    return new URL(path, this.getUrl().href).href;\n  }\n  /**\n   * In browsers we need to be able to (dynamically) check if fhir.js is\n   * included in the page. If it is, it should have created a \"fhir\" variable\n   * in the global scope.\n   */\n\n\n  get fhir() {\n    // @ts-ignore\n    return typeof fhir === \"function\" ? fhir : null;\n  }\n  /**\n   * Given the current environment, this method must return the current url\n   * as URL instance\n   */\n\n\n  getUrl() {\n    if (!this._url) {\n      this._url = new URL(location + \"\");\n    }\n\n    return this._url;\n  }\n  /**\n   * Given the current environment, this method must redirect to the given\n   * path\n   */\n\n\n  redirect(to) {\n    location.href = to;\n  }\n  /**\n   * Returns a BrowserStorage object which is just a wrapper around\n   * sessionStorage\n   */\n\n\n  getStorage() {\n    if (!this._storage) {\n      this._storage = new BrowserStorage_1.default();\n    }\n\n    return this._storage;\n  }\n  /**\n   * Returns a reference to the AbortController constructor. In browsers,\n   * AbortController will always be available as global (native or polyfilled)\n   */\n\n\n  getAbortController() {\n    return AbortController;\n  }\n  /**\n   * ASCII string to Base64\n   */\n\n\n  atob(str) {\n    return window.atob(str);\n  }\n  /**\n   * Base64 to ASCII string\n   */\n\n\n  btoa(str) {\n    return window.btoa(str);\n  }\n  /**\n   * Creates and returns adapter-aware SMART api. Not that while the shape of\n   * the returned object is well known, the arguments to this function are not.\n   * Those who override this method are free to require any environment-specific\n   * arguments. For example in node we will need a request, a response and\n   * optionally a storage or storage factory function.\n   */\n\n\n  getSmartApi() {\n    return {\n      ready: (...args) => smart_1.ready(this, ...args),\n      authorize: options => smart_1.authorize(this, options),\n      init: options => smart_1.init(this, options),\n      client: state => new Client_1.default(this, state),\n      options: this.options\n    };\n  }\n\n}\n\nexports.default = BrowserAdapter;"]},"metadata":{},"sourceType":"script"}